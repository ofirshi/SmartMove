/********************************************************************
Copyright (c) 2017, Check Point Software Technologies Ltd.
All rights reserved.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
********************************************************************/

using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Text;
using CommonUtils;
using CheckPointObjects;
using MigrationBase;
using Newtonsoft.Json;
using System.Diagnostics;
using System.Globalization;

namespace CiscoMigration
{
    /// <summary>
    /// Converts Cisco ASA commands repository into Check Point objects repository.
    /// Generates conversion reports for objects and policy packages.
    /// </summary>
    public class CiscoConverter : VendorConverter
    {
        #region Helper Classes

        private class DuplicateNameInfo
        {
            public int DuplicatesCount { get; set; }
            public bool IsCPPredefinedName { get; private set; }

            public DuplicateNameInfo(bool isCPPredefinedName)
            {
                DuplicatesCount = 0;
                IsCPPredefinedName = isCPPredefinedName;
            }
        }

        private class CiscoNetwork
        {
            public int CiscoCommandId { get; private set; }
            public string IpAddress { get; private set; }
            public string NetMask { get; private set; }
            public string MaskPrefix { get; set; }

            public CiscoNetwork(int ciscoCommandId, string sIp) : this(ciscoCommandId, sIp, "") { }
            public CiscoNetwork(int ciscoCommandId, string sIp, string sMask) : this(ciscoCommandId, sIp, sMask, "") { }
            public CiscoNetwork(int ciscoCommandId, string sIp, string sMask, string sMaskPrefix)
            {
                CiscoCommandId = ciscoCommandId;
                IpAddress = sIp;
                NetMask = string.IsNullOrEmpty(sMask) && string.IsNullOrEmpty(sMaskPrefix) ? "255.255.255.255" : sMask;
                MaskPrefix = sMaskPrefix;
            }

            public bool IsHost()
            {
                return NetworkUtils.IsValidIpv4(IpAddress) && (NetworkUtils.GetMaskLength(NetMask) == 32) || NetworkUtils.IsValidIpv6(IpAddress) && string.IsNullOrEmpty(MaskPrefix);
            }

            public bool IsNetwork()
            {
                return NetworkUtils.IsValidIpv4(IpAddress) && NetworkUtils.IsValidNetmaskv4(NetMask) && (NetworkUtils.GetMaskLength(NetMask) < 32) ||
                NetworkUtils.IsValidIpv6(IpAddress) && !string.IsNullOrEmpty(MaskPrefix);
            }

            public string AutoGeneratedName()
            {
                if (IsHost())
                {
                    return "host_" + IpAddress;
                }

                if (IsNetwork())
                {
                    if (!string.IsNullOrEmpty(NetMask))
                        return "network_" + IpAddress + "_" + NetworkUtils.GetMaskLength(NetMask);
                    else
                        return "network_" + IpAddress + "_" + MaskPrefix;
                }

                Console.WriteLine("Error: unrecognized network object - Ip={0}, Mask={1}", IpAddress, NetMask);
                return "_Err_in_network-line_" + CiscoCommandId;
            }

            public string AutoGeneratedNetworkName()
            {
                if (IsNetwork())
                {
                    if (!string.IsNullOrEmpty(NetMask))
                        return "network_" + IpAddress + "_" + NetworkUtils.GetMaskLength(NetMask);
                    else
                        return "network_" + IpAddress + "_" + MaskPrefix;
                }

                Console.WriteLine("Error: unrecognized network object - Ip={0}, Mask={1}, Prefix={2}", IpAddress, NetMask, MaskPrefix);
                return "_Err_in_network-line_" + CiscoCommandId;
            }

            public override bool Equals(object obj)
            {
                if (obj == null || GetType() != obj.GetType())
                {
                    return false;
                }

                var other = obj as CiscoNetwork;
                if (other == null)
                {
                    return false;
                }

                return (other.IpAddress == IpAddress && other.NetMask == NetMask && other.MaskPrefix == MaskPrefix);
            }

            public override int GetHashCode()
            {
                string hash = IpAddress + "," + NetMask + "," + MaskPrefix;
                return hash.GetHashCode();
            }
        }

        private class CiscoNatCustomData
        {
            public string Interface1 { get; set; }
            public string Interface2 { get; set; }
            public bool IsStaticMirrorRule { get; set; }
            public bool IsObjectNatRule { get; set; }
            public bool IsNonNatRule { get; set; }
            public bool IsAutoAfterSectionRule { get; set; }
            public bool IsNonNatSectionRule { get; set; }
        }

        private static class CheckPointServiceObjectsFactory
        {
            public static ProtocolType ProtocolStringToProtocolType(ref string sProtocol)
            {
                var protocol = ProtocolType.NA;

                switch (sProtocol)
                {
                    case "tcp":
                        protocol = ProtocolType.Tcp;
                        break;

                    case "udp":
                        protocol = ProtocolType.Udp;
                        break;

                    case "icmp":
                        protocol = ProtocolType.Icmp;
                        break;

                    case "ip":
                        protocol = ProtocolType.Ip;
                        break;

                    default:
                        string serviceName;
                        if (CiscoKnownServices.IsKnownService(sProtocol))
                        {
                            protocol = ProtocolType.KnownOtherIpProtocol;
                        }
                        else if (CiscoKnownServices.IsKnownServiceNumber(sProtocol, out serviceName))   // protocol number is used!!!
                        {
                            protocol = ProtocolType.KnownOtherIpProtocol;
                            sProtocol = serviceName;
                        }
                        else
                        {
                            Console.WriteLine("Error: Unrecognized service protocol '{0}'", sProtocol);
                        }
                        break;
                }

                return protocol;
            }

            public static string AutoGeneratedName(CheckPointObjectsRepository cpObjects, string sProtocol, string sPortOperator, string sPort, ServiceDirection where, int ciscoCommandId)
            {
                var protocol = ProtocolStringToProtocolType(ref sProtocol);
                if (protocol == ProtocolType.KnownOtherIpProtocol)
                {
                    sPort = sProtocol;
                }

                var portOperator = TcpUdpPortOperatorType.All;

                switch (sPortOperator)
                {
                    case "all":   // avoid error reporting...
                        break;

                    case "eq":
                        portOperator = TcpUdpPortOperatorType.Eq;
                        break;

                    case "gt":
                        portOperator = TcpUdpPortOperatorType.Gt;
                        break;

                    case "lt":
                        portOperator = TcpUdpPortOperatorType.Lt;
                        break;

                    default:
                        if (!string.IsNullOrEmpty(sPortOperator))
                        {
                            Console.WriteLine("Error: unsupported port operator '{0}'", sPortOperator);
                        }
                        break;
                }

                return AutoGeneratedName(cpObjects, protocol, portOperator, sPort, where, ciscoCommandId);
            }

            public static string AutoGeneratedName(CheckPointObjectsRepository cpObjects, ProtocolType protocol, TcpUdpPortOperatorType portOperator, string sPort, ServiceDirection where, int ciscoCommandId)
            {
                string name = "";
                bool serviceFound = false;

                switch (protocol)
                {
                    case ProtocolType.Tcp:
                        name = "TCP_";
                        if (portOperator == TcpUdpPortOperatorType.Gt)
                        {
                            portOperator = TcpUdpPortOperatorType.Range;
                            sPort = (int.Parse(sPort) + 1).ToString() + "-65535";
                        }
                        if (portOperator == TcpUdpPortOperatorType.Lt)
                        {
                            portOperator = TcpUdpPortOperatorType.Range;
                            sPort = "1-" + (int.Parse(sPort) - 1).ToString();
                        }
                        if (portOperator == TcpUdpPortOperatorType.Eq || portOperator == TcpUdpPortOperatorType.Range)
                        {
                            name = name + sPort;
                        }
                        if (portOperator == TcpUdpPortOperatorType.All)
                        {
                            name = name + "All";
                        }
                        if (portOperator == TcpUdpPortOperatorType.ReferenceObject)
                        {
                            name = sPort;
                        }
                        break;

                    case ProtocolType.Udp:
                        name = "UDP_";
                        if (portOperator == TcpUdpPortOperatorType.Gt)
                        {
                            portOperator = TcpUdpPortOperatorType.Range;
                            sPort = (int.Parse(sPort) + 1).ToString() + "-65535";
                        }
                        if (portOperator == TcpUdpPortOperatorType.Lt)
                        {
                            portOperator = TcpUdpPortOperatorType.Range;
                            sPort = "1-" + (int.Parse(sPort) - 1).ToString();
                        }
                        if (portOperator == TcpUdpPortOperatorType.Eq || portOperator == TcpUdpPortOperatorType.Range)
                        {
                            name = name + sPort;
                        }
                        if (portOperator == TcpUdpPortOperatorType.All)
                        {
                            name = name + "All";
                        }
                        if (portOperator == TcpUdpPortOperatorType.ReferenceObject)
                        {
                            name = sPort;
                        }
                        break;

                    case ProtocolType.Icmp:
                        name = "ICMP_" + CiscoKnownServices.ConvertIcmpServiceToType(sPort);
                        name = cpObjects.GetKnownServiceName(name, out serviceFound);
                        return serviceFound ? name : "icmp-proto";

                    case ProtocolType.Ip:
                        if (portOperator == TcpUdpPortOperatorType.All)
                        {
                            name = CheckPointObject.Any;
                        }
                        else
                        {
                            Console.WriteLine("Error: unsupported port operator '{0}' for protocol IP", portOperator);
                            name = "_Err_in_service-line_" + ciscoCommandId;
                        }
                        return name;

                    case ProtocolType.KnownOtherIpProtocol:
                        name = "OTHER_" + CiscoKnownServices.ConvertServiceToPort(sPort);
                        name = cpObjects.GetKnownServiceName(name, out serviceFound);
                        return serviceFound ? name : sPort;

                    case ProtocolType.NA:
                        Console.WriteLine("Error: Unrecognized service protocol");
                        return "_Err_in_service-line_" + ciscoCommandId;
                }

                if (where == ServiceDirection.Source)
                {
                    name = name + "_SourcePort";
                }

                return cpObjects.GetKnownServiceName(name, out serviceFound);
            }

            public static CheckPointObject CreateServiceObj(CheckPointObjectsRepository cpObjects, ProtocolType protocol, TcpUdpPortOperatorType portOperator, string sPort, ServiceDirection where, int ciscoCommandId)
            {
                CheckPointObject serviceObj = null;

                switch (protocol)
                {
                    case ProtocolType.Tcp:
                        if (portOperator == TcpUdpPortOperatorType.ReferenceObject)
                        {
                            // Skip, the referenced object will be created on its own!!!
                            return null;
                        }

                        var tcp = new CheckPoint_TcpService();

                        if (portOperator == TcpUdpPortOperatorType.Eq ||
                            portOperator == TcpUdpPortOperatorType.Range ||
                            portOperator == TcpUdpPortOperatorType.All ||
                            portOperator == TcpUdpPortOperatorType.Gt ||
                            portOperator == TcpUdpPortOperatorType.Lt)
                        {
                            string objName = AutoGeneratedName(cpObjects, protocol, portOperator, sPort, where, ciscoCommandId);

                            if (portOperator == TcpUdpPortOperatorType.All)
                            {
                                sPort = "1-65535";
                            }
                            if (portOperator == TcpUdpPortOperatorType.Gt)
                            {
                                sPort = (int.Parse(sPort) + 1).ToString() + "-65535";
                            }
                            if (portOperator == TcpUdpPortOperatorType.Lt)
                            {
                                sPort = "1-" + (int.Parse(sPort) - 1).ToString();
                            }
                            if (where == ServiceDirection.Destination)
                            {
                                tcp.Port = sPort;
                            }
                            if (where == ServiceDirection.Source)
                            {
                                tcp.SourcePort = sPort;
                                tcp.Port = "1-65535";
                            }
                            tcp.Name = objName;
                            serviceObj = tcp;
                        }
                        break;

                    case ProtocolType.Udp:
                        if (portOperator == TcpUdpPortOperatorType.ReferenceObject)
                        {
                            // Skip, the referenced object will be created on its own!!!
                            return null;
                        }

                        var udp = new CheckPoint_UdpService();

                        if (portOperator == TcpUdpPortOperatorType.Eq ||
                            portOperator == TcpUdpPortOperatorType.Range ||
                            portOperator == TcpUdpPortOperatorType.All ||
                            portOperator == TcpUdpPortOperatorType.Gt ||
                            portOperator == TcpUdpPortOperatorType.Lt)
                        {
                            string objName = AutoGeneratedName(cpObjects, protocol, portOperator, sPort, where, ciscoCommandId);

                            if (portOperator == TcpUdpPortOperatorType.All)
                            {
                                sPort = "1-65535";
                            }
                            if (portOperator == TcpUdpPortOperatorType.Gt)
                            {
                                sPort = (int.Parse(sPort) + 1).ToString() + "-65535";
                            }
                            if (portOperator == TcpUdpPortOperatorType.Lt)
                            {
                                sPort = "1-" + (int.Parse(sPort) - 1).ToString();
                            }
                            if (where == ServiceDirection.Destination)
                            {
                                udp.Port = sPort;
                            }
                            if (where == ServiceDirection.Source)
                            {
                                udp.SourcePort = sPort;
                                udp.Port = "1-65535";
                            }
                            udp.Name = objName;
                            serviceObj = udp;
                        }
                        break;

                    case ProtocolType.Icmp:
                        // Skip, a predefined "icmp" object is used!!!
                        break;

                    case ProtocolType.Ip:
                        if (portOperator != TcpUdpPortOperatorType.All)
                        {
                            Console.WriteLine("Error: Service protocol is 'IP', but the service is not 'any'");
                        }
                        // Skip, a predefined "any" object is used!!!
                        break;

                    case ProtocolType.KnownOtherIpProtocol:
                        {
                            string objName = AutoGeneratedName(cpObjects, protocol, portOperator, sPort, where, ciscoCommandId);
                            if (!string.IsNullOrEmpty(objName))
                            {
                                var other = new CheckPoint_OtherService();
                                other.Name = objName;
                                other.IpProtocol = CiscoKnownServices.ConvertServiceToPort(sPort);
                                serviceObj = other;
                            }
                        }
                        break;

                    case ProtocolType.NA:
                        Console.WriteLine("Error: Service protocol is 'NA'");
                        break;
                }

                return serviceObj;
            }

            public static bool CheckServicesPortRangesOverlapping(CheckPointObject subsetService, CheckPointObject supersetService)
            {
                int subsetTcpPortFrom, subsetTcpPortTo;
                int supersetTcpPortFrom, supersetTcpPortTo;

                if (subsetService.GetType() == typeof(CheckPoint_TcpService) && supersetService.GetType() == typeof(CheckPoint_TcpService))
                {
                    var subsetTcp = (CheckPoint_TcpService)subsetService;
                    var supersetTcp = (CheckPoint_TcpService)supersetService;

                    GetServicePortRanges(subsetTcp.Port, out subsetTcpPortFrom, out subsetTcpPortTo);
                    GetServicePortRanges(supersetTcp.Port, out supersetTcpPortFrom, out supersetTcpPortTo);
                }
                else if (subsetService.GetType() == typeof(CheckPoint_UdpService) && supersetService.GetType() == typeof(CheckPoint_UdpService))
                {
                    var subsetUdp = (CheckPoint_UdpService)subsetService;
                    var supersetUdp = (CheckPoint_UdpService)supersetService;

                    GetServicePortRanges(subsetUdp.Port, out subsetTcpPortFrom, out subsetTcpPortTo);
                    GetServicePortRanges(supersetUdp.Port, out supersetTcpPortFrom, out supersetTcpPortTo);
                }
                else
                {
                    return false;
                }

                if (subsetTcpPortFrom >= supersetTcpPortFrom && subsetTcpPortTo <= supersetTcpPortTo)
                {
                    return true;
                }

                return false;
            }

            private static void GetServicePortRanges(string servicePort, out int from, out int to)
            {
                if (servicePort.Contains("-"))
                {
                    string[] ranges = servicePort.Split('-');
                    int.TryParse(ranges[0], out from);
                    int.TryParse(ranges[1], out to);
                }
                else   // no range
                {
                    int.TryParse(servicePort, out from);
                    int.TryParse(servicePort, out to);
                }
            }
        }

        #endregion

        #region Private Members

        private CiscoParser _ciscoParser;
        private HashSet<CiscoNetwork> _ciscoNetworkObjects;
        private IEnumerable<CiscoCommand> _ciscoAllCommands;
        private IEnumerable<CiscoCommand> _ciscoObjectCommands;
        private IEnumerable<CiscoCommand> _ciscoObjectGroupCommands;
        private IEnumerable<CiscoCommand> _ciscoAclCommands;
        private IEnumerable<CiscoCommand> _ciscoAccessGroupCommands;
        private IEnumerable<CiscoCommand> _ciscoInterfaceCommands;
        private IEnumerable<CiscoCommand> _ciscoTimeRangeCommands;
        private IEnumerable<CiscoCommand> _ciscoClassMapCommands;
        private IList<CiscoCommand> _ciscoSshCommands;
        private Cisco_Hostname _ciscoHostnameCommand;
        private List<Cisco_AccessList> _ciscoGlobalAclCommands = new List<Cisco_AccessList>();

        private List<CheckPoint_NAT_Rule> _cpPreorderedNatRules = new List<CheckPoint_NAT_Rule>();

        private Dictionary<string, DuplicateNameInfo> _duplicateNamesLookup = new Dictionary<string, DuplicateNameInfo>(StringComparer.InvariantCultureIgnoreCase);
        private List<string> _ciscoServiceInvalidNames = new List<string>();
        private List<string> _ciscoFqdnInvalidNames = new List<string>();
        private List<string> _cpUnsafeNames = new List<string>();

        private bool _isInterInterfaceTrafficAllowed = false;
        private bool _isIntraInterfaceTrafficAllowed = false;

        private Dictionary<string, List<string>> _ciscoTimeNamesToCpTimeNamesDict = new Dictionary<string, List<string>>();

        private enum CheckPointDummyObjectType { Host, NetworkGroup, ServiceGroup, OtherService, TimeGroup };

        private IEnumerable<CiscoCommand> CiscoAllCommands
        {
            get
            {
                return _ciscoAllCommands ?? (_ciscoAllCommands = _ciscoParser.Flatten());
            }
        }

        private IEnumerable<CiscoCommand> CiscoObjectCommands
        {
            get
            {
                return _ciscoObjectCommands ?? (_ciscoObjectCommands = _ciscoParser.Filter("object"));
            }
        }

        private IEnumerable<CiscoCommand> CiscoObjectGroupCommands
        {
            get
            {
                return _ciscoObjectGroupCommands ?? (_ciscoObjectGroupCommands = _ciscoParser.Filter("object-group"));
            }
        }

        private IEnumerable<CiscoCommand> CiscoAclCommands
        {
            get
            {
                return _ciscoAclCommands ?? (_ciscoAclCommands = _ciscoParser.Filter("access-list"));
            }
        }

        private IEnumerable<CiscoCommand> CiscoAccessGroupCommands
        {
            get
            {
                return _ciscoAccessGroupCommands ?? (_ciscoAccessGroupCommands = _ciscoParser.Filter("access-group"));
            }
        }

        private IEnumerable<CiscoCommand> CiscoInterfaceCommands
        {
            get
            {
                return _ciscoInterfaceCommands ?? (_ciscoInterfaceCommands = _ciscoParser.Filter("interface"));
            }
        }

        private IEnumerable<CiscoCommand> CisciTimeRangeCommands
        {
            get
            {
                return _ciscoTimeRangeCommands ?? (_ciscoTimeRangeCommands = _ciscoParser.Filter("time-range"));
            }
        }

        private IEnumerable<CiscoCommand> CiscoClassMapCommands
        {
            get
            {
                return _ciscoClassMapCommands ?? (_ciscoClassMapCommands = _ciscoParser.Filter("class-map"));
            }
        }

        private IList<CiscoCommand> CiscoSshCommands
        {
            get
            {
                if (_ciscoSshCommands == null)
                {
                    _ciscoSshCommands = new List<CiscoCommand>();
                    var sshCommands = _ciscoParser.Filter("ssh");

                    foreach (var sshCommand in sshCommands)
                    {
                        if (sshCommand.ConversionIncidentType == ConversionIncidentType.None)
                        {
                            _ciscoSshCommands.Add(sshCommand);
                        }
                    }
                }

                return _ciscoSshCommands;
            }
        }

        private Cisco_Hostname CiscoHostnameCommand
        {
            get
            {
                return _ciscoHostnameCommand ?? (_ciscoHostnameCommand = _ciscoParser.Filter("hostname").FirstOrDefault() as Cisco_Hostname);
            }
        }

        #endregion

        #region Private Methods

        protected override bool AddCheckPointObject(CheckPointObject cpObject)
        {
            if (base.AddCheckPointObject(cpObject))
            {
                string vendor = Vendor.CiscoASA.ToString();
                if (!cpObject.Tags.Contains(vendor))
                {
                    cpObject.Tags.Add(vendor);
                }
            }

            return false;
        }

        private void ApplyConversionIncidentOnCheckPointObject(CheckPointObject cpObject, CiscoCommand ciscoCommand)
        {
            cpObject.ConvertedCommandId = ciscoCommand.Id;

            if (ciscoCommand.ConversionIncidentType != ConversionIncidentType.None)
            {
                cpObject.ConversionIncidentType = ciscoCommand.ConversionIncidentType;

                if (!string.IsNullOrEmpty(ciscoCommand.ConversionIncidentMessage))
                {
                    string ciscoObject = string.IsNullOrEmpty(ciscoCommand.CiscoId) ? ciscoCommand.Text : ciscoCommand.CiscoId;
                    string errorDesc = ciscoCommand.Name() + " details: " + ciscoObject + ".";

                    _conversionIncidents.Add(new ConversionIncident(ciscoCommand.Id,
                                                                    ciscoCommand.ConversionIncidentMessage,
                                                                    errorDesc,
                                                                    ciscoCommand.ConversionIncidentType));
                }
            }
        }

        private void CheckObjectNameValidity(CheckPointObject cpObject, CiscoCommand ciscoCommand)
        {
            string originalName = cpObject.Name;

            if (string.IsNullOrEmpty(originalName))
            {
                ciscoCommand.ConversionIncidentType = ConversionIncidentType.ManualActionRequired;

                string errorDescription = string.Format("Cisco command: {0}.", ciscoCommand.Text);
                _conversionIncidents.Add(new ConversionIncident(ciscoCommand.Id,
                                                                "Object name cannot be empty. Please review for further possible modifications to objects before migration.",
                                                                errorDescription,
                                                                ciscoCommand.ConversionIncidentType));

                return;
            }

            if (originalName != cpObject.SafeName())
            {
                _cpUnsafeNames.Add(originalName);
            }

            if (cpObject.GetType().ToString().EndsWith("_TcpService") || cpObject.GetType().ToString().EndsWith("_UdpService"))
            {
                // TCP/UDP service name must start with a letter!!!
                if (!Char.IsLetter(originalName[0]))
                {
                    _ciscoServiceInvalidNames.Add(originalName);

                    ciscoCommand.ConversionIncidentType = ConversionIncidentType.Informative;
                    cpObject.ConversionIncidentType = ConversionIncidentType.Informative;   // report on converted object as well!!!

                    string errorDescription = string.Format("Service original name: {0}. Modified name: {1}", originalName, InvalidServiceNamePrefix + originalName);
                    _conversionIncidents.Add(new ConversionIncident(ciscoCommand.Id,
                                                                    "TCP/UDP service object name must start with a letter. Modifying the original name to a Check Point valid name.",
                                                                    errorDescription,
                                                                    ciscoCommand.ConversionIncidentType));
                }
            }

            if (cpObject.GetType().ToString().EndsWith("_Domain"))
            {
                bool isFqdn = true;

                // Check for domain name and fqdn name
                var cpDomain = (CheckPoint_Domain)cpObject;
                if (originalName != cpDomain.Fqdn)
                {
                    isFqdn = false;
                    _ciscoFqdnInvalidNames.Add(originalName);

                    ciscoCommand.ConversionIncidentType = ConversionIncidentType.Informative;
                    cpObject.ConversionIncidentType = ConversionIncidentType.Informative;   // report on converted object as well!!!

                    string errorDescription = string.Format("Domain object name: {0}. FQDN name: {1}", originalName, cpDomain.Fqdn);
                    _conversionIncidents.Add(new ConversionIncident(ciscoCommand.Id,
                                                                    "Cisco Domain object name differs from FQDN name. Using FQDN name as converted Domain object name.",
                                                                    errorDescription,
                                                                    ciscoCommand.ConversionIncidentType));
                }

                // Fqdn name must start with a dot!!!
                if ((isFqdn && !originalName.StartsWith(".")) || !cpDomain.Fqdn.StartsWith("."))
                {
                    if (isFqdn)   // do not add twice...
                    {
                        _ciscoFqdnInvalidNames.Add(originalName);
                    }

                    ciscoCommand.ConversionIncidentType = ConversionIncidentType.Informative;
                    cpObject.ConversionIncidentType = ConversionIncidentType.Informative;   // report on converted object as well!!!

                    string errorDescription = string.Format("Domain original FQDN name: {0}. Modified name: {1}", isFqdn ? originalName : cpDomain.Fqdn, "." + cpDomain.Fqdn);
                    _conversionIncidents.Add(new ConversionIncident(ciscoCommand.Id,
                                                                    "Domain FQDN name must start with a dot. Modifying the original name to a Check Point valid name.",
                                                                    errorDescription,
                                                                    ciscoCommand.ConversionIncidentType));
                }
            }

            DuplicateNameInfo duplicateNameInfo;
            if (_duplicateNamesLookup.TryGetValue(originalName, out duplicateNameInfo))
            {
                ++duplicateNameInfo.DuplicatesCount;
                _duplicateNamesLookup[originalName] = duplicateNameInfo;

                string uniqueName = string.Format("{0}_{1}", originalName, duplicateNameInfo.DuplicatesCount);
                cpObject.Name = uniqueName;

                ciscoCommand.ConversionIncidentType = ConversionIncidentType.ManualActionRequired;

                string errorTitle = duplicateNameInfo.IsCPPredefinedName
                                        ? "Detected an object with a same name in Check Point's predefined service objects repository."
                                        : "Detected an object with a non unique name. Check Point names should be case insensitive.";
                errorTitle += " Please review for further possible modifications to objects before migration.";
                string errorDescription = string.Format("Original name: {0}. Using unique name: {1}.", originalName, uniqueName);

                _conversionIncidents.Add(new ConversionIncident(ciscoCommand.Id, errorTitle, errorDescription, ciscoCommand.ConversionIncidentType));

                return;
            }

            _duplicateNamesLookup.Add(originalName, new DuplicateNameInfo(false));
        }

        private void EnforceObjectNameValidity()
        {
            // Fix invalid TCP/UDP service names
            foreach (var invalidName in _ciscoServiceInvalidNames)
            {
                bool found = false;
                string validName = InvalidServiceNamePrefix + invalidName;

                // Search in TCP services
                foreach (var tcpService in _cpTcpServices)
                {
                    if (invalidName == tcpService.Name)
                    {
                        tcpService.Name = validName;
                        found = true;
                        break;
                    }
                }

                // Otherwise, search in UDP services
                if (!found)
                {
                    foreach (var udpService in _cpUdpServices)
                    {
                        if (invalidName == udpService.Name)
                        {
                            udpService.Name = validName;
                            break;
                        }
                    }
                }

                // Finally, search references in service groups
                foreach (var serviceGroup in _cpServiceGroups)
                {
                    int pos = serviceGroup.Members.IndexOf(invalidName);
                    if (pos != -1)
                    {
                        serviceGroup.Members[pos] = validName;
                    }
                }
            }

            // Fix invalid domain names
            foreach (var invalidName in _ciscoFqdnInvalidNames)
            {
                string validName = "";

                foreach (var domain in _cpDomains)
                {
                    if (invalidName == domain.Name)
                    {
                        validName = "." + domain.Fqdn;
                        domain.Name = validName;
                        break;
                    }
                }

                // Finally, search references in network groups
                foreach (var networkGroup in _cpNetworkGroups)
                {
                    int pos = networkGroup.Members.IndexOf(invalidName);
                    if (pos != -1)
                    {
                        networkGroup.Members[pos] = validName;
                    }
                }
            }

            // Fix unsafe names
            foreach (var unsafeName in _cpUnsafeNames)
            {
                CheckPointObject cpObject = _cpObjects.GetObject(unsafeName);
                if (cpObject != null)
                {
                    cpObject.Name = cpObject.SafeName();

                    // Search references in service groups
                    foreach (var serviceGroup in _cpServiceGroups)
                    {
                        int pos = serviceGroup.Members.IndexOf(unsafeName);
                        if (pos != -1)
                        {
                            serviceGroup.Members[pos] = cpObject.Name;
                        }
                    }

                    // Search references in network groups
                    foreach (var networkGroup in _cpNetworkGroups)
                    {
                        int pos = networkGroup.Members.IndexOf(unsafeName);
                        if (pos != -1)
                        {
                            networkGroup.Members[pos] = cpObject.Name;
                        }
                    }

                    // Search references in network groups with exclusion
                    foreach (var networkGroup in _cpGroupsWithExclusion)
                    {
                        if (networkGroup.Include == unsafeName)
                        {
                            networkGroup.Include = cpObject.Name;
                        }
                        if (networkGroup.Except == unsafeName)
                        {
                            networkGroup.Except = cpObject.Name;
                        }
                    }
                }
            }
        }

        private CheckPointObject GetCheckPointObjectOrCreateDummy(string cpObjectName, CheckPointDummyObjectType dummyObjectType, CiscoCommand ciscoCommand, string errorTitle, string errorDescription)
        {
            var cpObject = _cpObjects.GetObject(cpObjectName);
            if (cpObject != null)
            {
                return cpObject;
            }

            CheckPointObject cpDummyObject = null;

            switch (dummyObjectType)
            {
                case CheckPointDummyObjectType.Host:
                    cpDummyObject = new CheckPoint_Host { Name = "_Err_in_network-line_" + ciscoCommand.Id, IpAddress = "1.1.1.1" };
                    break;

                case CheckPointDummyObjectType.NetworkGroup:
                    cpDummyObject = new CheckPoint_NetworkGroup { Name = "_Err_in_topology-line_" + ciscoCommand.Id };
                    break;

                case CheckPointDummyObjectType.ServiceGroup:
                    cpDummyObject = new CheckPoint_ServiceGroup { Name = "_Err_in_service-line_" + ciscoCommand.Id };
                    break;

                case CheckPointDummyObjectType.TimeGroup:
                    cpDummyObject = new CheckPoint_TimeGroup { Name = "_Err_L" + ciscoCommand.Id };   // time object name is limited to 11 characters!!!
                    break;

                case CheckPointDummyObjectType.OtherService:
                    if (!string.IsNullOrEmpty(cpObjectName))
                    {
                        cpDummyObject = CheckPointServiceObjectsFactory.CreateServiceObj(_cpObjects,
                                                                                         ProtocolType.KnownOtherIpProtocol,
                                                                                         TcpUdpPortOperatorType.NA,
                                                                                         cpObjectName,
                                                                                         ServiceDirection.Destination,
                                                                                         ciscoCommand.Id);
                        if (cpDummyObject != null && cpDummyObject.GetType() == typeof(CheckPoint_OtherService))
                        {
                            cpDummyObject.ConvertedCommandId = ciscoCommand.Id;
                            AddCheckPointObject(cpDummyObject);
                            return cpDummyObject;
                        }
                    }

                    cpDummyObject = new CheckPoint_ServiceGroup { Name = "_Err_in_service-line_" + ciscoCommand.Id };
                    break;
            }

            if (cpDummyObject != null)
            {
                cpDummyObject.ConvertedCommandId = ciscoCommand.Id;
                cpDummyObject.ConversionIncidentType = ConversionIncidentType.ManualActionRequired;
                AddCheckPointObject(cpDummyObject);

                ciscoCommand.ConversionIncidentType = ConversionIncidentType.ManualActionRequired;

                errorDescription = string.Format("{0} Using dummy object: {1}.", errorDescription, cpDummyObject.Name);
                _conversionIncidents.Add(new ConversionIncident(ciscoCommand.Id, errorTitle, errorDescription, ciscoCommand.ConversionIncidentType));
            }

            return cpDummyObject;
        }

        private CheckPointObject GetCheckPointObjectOrCreateDummyFromNetworkGroupWithSingleMember(CheckPoint_NetworkGroup networkGroup, CiscoCommand ciscoCommand, bool createDummy = true)
        {
            if (networkGroup.Members.Count == 1)
            {
                var cpObject = _cpObjects.GetObject(networkGroup.Members[0]);
                if (cpObject != null)
                {
                    return cpObject;
                }
            }

            if (createDummy)
            {
                return GetCheckPointObjectOrCreateDummy("not_existing_object",
                                                        CheckPointDummyObjectType.Host,
                                                        ciscoCommand,
                                                        "Error creating a NAT rule, group object cannot be used as a translated object",
                                                        "Group object details: " + networkGroup.Name + ".");
            }

            return networkGroup;
        }

        private void PopulateCiscoNetworkObjects()
        {
            _ciscoNetworkObjects = new HashSet<CiscoNetwork>();

            foreach (CiscoCommand command in CiscoAllCommands)
            {
                if (command.Name() == "network-object")
                {
                    var ciscoNetwork = (Cisco_NetworkObject)command;

                    // The referenced object will be created on its own!!!
                    if (string.IsNullOrEmpty(ciscoNetwork.ReferencedObject))
                    {
                        var network = new CiscoNetwork(command.Id, ciscoNetwork.IpAddress, ciscoNetwork.Netmask, ciscoNetwork.MaskPrefix);
                        _ciscoNetworkObjects.Add(network);
                    }
                }
            }

            foreach (CiscoCommand command in CiscoAclCommands)
            {
                var ciscoAcl = (Cisco_AccessList)command;
                if (ciscoAcl.IsRemark)
                {
                    continue;
                }

                CiscoNetwork source;
                CiscoNetwork dest;

                if (ciscoAcl.Source.Type == Cisco_AccessList.SourceDest.SourceDestType.Host)
                {
                    source = new CiscoNetwork(ciscoAcl.Id, ciscoAcl.Source.HostIp);
                    _ciscoNetworkObjects.Add(source);
                }

                if (ciscoAcl.Source.Type == Cisco_AccessList.SourceDest.SourceDestType.SubnetAndMask)
                {
                    source = new CiscoNetwork(ciscoAcl.Id, ciscoAcl.Source.Subnet, ciscoAcl.Source.Netmask);
                    _ciscoNetworkObjects.Add(source);
                }

                if (ciscoAcl.Destination.Type == Cisco_AccessList.SourceDest.SourceDestType.Host)
                {
                    dest = new CiscoNetwork(ciscoAcl.Id, ciscoAcl.Destination.HostIp);
                    _ciscoNetworkObjects.Add(dest);
                }

                if (ciscoAcl.Destination.Type == Cisco_AccessList.SourceDest.SourceDestType.SubnetAndMask)
                {
                    dest = new CiscoNetwork(ciscoAcl.Id, ciscoAcl.Destination.Subnet, ciscoAcl.Destination.Netmask);
                    _ciscoNetworkObjects.Add(dest);
                }
            }
        }

        private void CheckCiscoInterfacesTraffic()
        {
            var ciscoInterfacesTraffic = _ciscoParser.Filter("same-security-traffic");

            foreach (var ciscoCommand in ciscoInterfacesTraffic)
            {
                var ciscoInterfaceTraffic = (Cisco_SameSecurityTraffic)ciscoCommand;

                if (ciscoInterfaceTraffic.TrafficType == Cisco_SameSecurityTraffic.InterfaceTrafficType.Inter)
                {
                    _isInterInterfaceTrafficAllowed = true;
                }

                if (ciscoInterfaceTraffic.TrafficType == Cisco_SameSecurityTraffic.InterfaceTrafficType.Intra)
                {
                    _isIntraInterfaceTrafficAllowed = true;
                }
            }
        }

        private void CheckCiscoInterfacesAntiSpoofing()
        {
            var ciscoAntiSpoofingCommands = _ciscoParser.Filter("ip verify reverse-path interface");

            foreach (var ciscoCommand in ciscoAntiSpoofingCommands)
            {
                var ciscoAntiSpoofing = (Cisco_AntiSpoofing)ciscoCommand;

                if (!string.IsNullOrEmpty(ciscoAntiSpoofing.InterfaceName))
                {
                    ciscoCommand.ConversionIncidentType = ConversionIncidentType.Informative;

                    _conversionIncidents.Add(new ConversionIncident(ciscoAntiSpoofing.Id,
                                                                    "Interface Anti-Spoofing settings should be manually fixed after migration",
                                                                    "Interface name: " + ciscoAntiSpoofing.InterfaceName,
                                                                    ConversionIncidentType.Informative));
                }
            }
        }

        private void Add_Networks()
        {
            foreach (CiscoNetwork network in _ciscoNetworkObjects)
            {
                if (network.IsHost())
                {
                    var cpHost = new CheckPoint_Host();
                    cpHost.Name = network.AutoGeneratedName();
                    cpHost.IpAddress = network.IpAddress;
                    cpHost.ConvertedCommandId = network.CiscoCommandId;
                    AddCheckPointObject(cpHost);
                }
                else if (network.IsNetwork())
                {
                    var cpNetwork = new CheckPoint_Network();
                    cpNetwork.Name = network.AutoGeneratedName();
                    cpNetwork.Subnet = network.IpAddress;
                    cpNetwork.Netmask = network.NetMask;
                    cpNetwork.MaskLenght = network.MaskPrefix;
                    cpNetwork.ConvertedCommandId = network.CiscoCommandId;
                    AddCheckPointObject(cpNetwork);
                }
            }
        }

        private void Add_Objects()
        {
            foreach (CiscoCommand command in CiscoObjectCommands)
            {
                var ciscoObject = (Cisco_Object)command;

                switch (ciscoObject.ObjectType)
                {
                    case Cisco_Object.ObjectTypes.Fqdn:
                        var cpDomain = new CheckPoint_Domain();
                        cpDomain.Name = ciscoObject.CiscoId;
                        cpDomain.Comments = ciscoObject.Description;
                        cpDomain.Fqdn = ciscoObject.Fqdn;
                        ApplyConversionIncidentOnCheckPointObject(cpDomain, ciscoObject);
                        CheckObjectNameValidity(cpDomain, ciscoObject);
                        AddCheckPointObject(cpDomain);
                        break;

                    case Cisco_Object.ObjectTypes.Host:
                        var cpHost = new CheckPoint_Host();
                        cpHost.Name = ciscoObject.CiscoId;
                        cpHost.Comments = ciscoObject.Description;
                        cpHost.IpAddress = ciscoObject.HostAddress;
                        ApplyConversionIncidentOnCheckPointObject(cpHost, ciscoObject);
                        CheckObjectNameValidity(cpHost, ciscoObject);
                        AddCheckPointObject(cpHost);
                        break;

                    case Cisco_Object.ObjectTypes.Network:
                        var cpNetwork = new CheckPoint_Network();
                        cpNetwork.Name = ciscoObject.CiscoId;
                        cpNetwork.Comments = ciscoObject.Description;
                        cpNetwork.Subnet = ciscoObject.Network;
                        cpNetwork.Netmask = ciscoObject.Netmask;
                        cpNetwork.MaskLenght = ciscoObject.MaskPrefix;
                        ApplyConversionIncidentOnCheckPointObject(cpNetwork, ciscoObject);
                        CheckObjectNameValidity(cpNetwork, ciscoObject);
                        AddCheckPointObject(cpNetwork);
                        break;

                    case Cisco_Object.ObjectTypes.Range:
                        var cpRange = new CheckPoint_Range();
                        cpRange.Name = ciscoObject.CiscoId;
                        cpRange.Comments = ciscoObject.Description;
                        cpRange.RangeFrom = ciscoObject.RangeFrom;
                        cpRange.RangeTo = ciscoObject.RangeTo;
                        ApplyConversionIncidentOnCheckPointObject(cpRange, ciscoObject);
                        CheckObjectNameValidity(cpRange, ciscoObject);
                        AddCheckPointObject(cpRange);
                        break;

                    case Cisco_Object.ObjectTypes.TcpService:
                        var cpTcp = new CheckPoint_TcpService();
                        cpTcp.Name = ciscoObject.CiscoId;
                        cpTcp.Comments = ciscoObject.Description;
                        cpTcp.Port = ciscoObject.ServicePort;
                        ApplyConversionIncidentOnCheckPointObject(cpTcp, ciscoObject);
                        CheckObjectNameValidity(cpTcp, ciscoObject);
                        AddCheckPointObject(cpTcp);
                        break;

                    case Cisco_Object.ObjectTypes.UdpService:
                        var cpUdp = new CheckPoint_UdpService();
                        cpUdp.Name = ciscoObject.CiscoId;
                        cpUdp.Comments = ciscoObject.Description;
                        cpUdp.Port = ciscoObject.ServicePort;
                        ApplyConversionIncidentOnCheckPointObject(cpUdp, ciscoObject);
                        CheckObjectNameValidity(cpUdp, ciscoObject);
                        AddCheckPointObject(cpUdp);
                        break;

                    case Cisco_Object.ObjectTypes.KnownOtherService:
                        var cpOtherService = CheckPointServiceObjectsFactory.CreateServiceObj(_cpObjects,
                                                                                              ProtocolType.KnownOtherIpProtocol,
                                                                                              TcpUdpPortOperatorType.NA,
                                                                                              ciscoObject.ServiceProtocol,
                                                                                              ServiceDirection.Destination,
                                                                                              ciscoObject.Id);
                        if (cpOtherService != null && cpOtherService.GetType() == typeof(CheckPoint_OtherService))
                        {
                            cpOtherService.Comments = ciscoObject.Description;
                            ApplyConversionIncidentOnCheckPointObject(cpOtherService, ciscoObject);
                            AddCheckPointObject(cpOtherService);
                        }
                        break;

                    case Cisco_Object.ObjectTypes.IcmpService:
                        // Predefined "icmp" object. No special handling...
                        break;
                }
            }
        }

        private void Add_NetworkGroups()
        {
            foreach (CiscoCommand command in CiscoObjectGroupCommands)
            {
                var ciscoGroup = (Cisco_GroupObject)command;

                if (ciscoGroup.GroupType == Cisco_GroupObject.Group_Type.Network)
                {
                    var cpNetworkGroup = new CheckPoint_NetworkGroup();
                    cpNetworkGroup.Name = ciscoGroup.CiscoId;
                    cpNetworkGroup.Comments = ciscoGroup.Description;
                    ApplyConversionIncidentOnCheckPointObject(cpNetworkGroup, ciscoGroup);
                    CheckObjectNameValidity(cpNetworkGroup, ciscoGroup);

                    foreach (string groupName in ciscoGroup.MembersGroupNames)
                    {
                        cpNetworkGroup.Members.Add(groupName);
                    }

                    foreach (Cisco_NetworkObject ciscoMember in ciscoGroup.MemberObjects)
                    {
                        if (!string.IsNullOrEmpty(ciscoMember.ReferencedObject))
                        {
                            cpNetworkGroup.Members.Add(ciscoMember.ReferencedObject);
                        }
                        else
                        {
                            string memberName = (new CiscoNetwork(ciscoMember.Id, ciscoMember.IpAddress, ciscoMember.Netmask, ciscoMember.MaskPrefix)).AutoGeneratedName();
                            if (memberName.Contains(AutoGeneratedNameWithError))
                            {
                                ciscoMember.ConversionIncidentType = ConversionIncidentType.ManualActionRequired;
                                ciscoMember.ConversionIncidentMessage = "Unrecognized network details: " + ciscoMember.IpAddress + " " + ciscoMember.Netmask + ".";
                            }

                            ApplyConversionIncidentOnCheckPointObject(cpNetworkGroup, ciscoMember);
                            cpNetworkGroup.Members.Add(memberName);
                        }
                    }

                    AddCheckPointObject(cpNetworkGroup);
                }
            }
        }

        private void Add_InterfacesAndRoutes()
        {
            // This interface is for the TOP rule for the Non-NAT rules section!!!
            var allInternal = new CheckPoint_NetworkGroup();
            allInternal.Name = AllInternalNetwotkGroupName;

            int ciscoCommandIdWithIncident = 0;

            foreach (CiscoCommand command in CiscoInterfaceCommands)
            {
                var ciscoInterface = (Cisco_Interface)command;
                if (string.IsNullOrEmpty(ciscoInterface.CiscoId) || !ciscoInterface.HasValidIpAddress())
                {
                    // must be interface with a name and IP address!!!
                    continue;
                }

                if (!ciscoInterface.LeadsToInternet)
                {
                    var cpNetworkGroup = new CheckPoint_NetworkGroup();
                    cpNetworkGroup.Name = ciscoInterface.CiscoId + "_subnets";

                    foreach (Cisco_Interface.Subnet subnet in ciscoInterface.Topology)
                    {
                        // Note, that a subnet can be a host in Cisco, but we want to always convert to network in CP!!!
                        string networkName = (new CiscoNetwork(ciscoInterface.Id, subnet.Network, subnet.Netmask)).AutoGeneratedNetworkName();
                        if (networkName.Contains(AutoGeneratedNameWithError))
                        {
                            ciscoInterface.ConversionIncidentType = ConversionIncidentType.ManualActionRequired;
                            ciscoInterface.ConversionIncidentMessage = "Unrecognized topology details: " + subnet.Network + " " + subnet.Netmask + ".";

                            ciscoCommandIdWithIncident = ciscoInterface.Id;
                        }

                        var cpNetwork = new CheckPoint_Network();
                        cpNetwork.Name = networkName;
                        cpNetwork.Subnet = subnet.Network;
                        cpNetwork.Netmask = subnet.Netmask;
                        AddCheckPointObject(cpNetwork);

                        cpNetworkGroup.Members.Add(cpNetwork.Name);
                    }

                    ApplyConversionIncidentOnCheckPointObject(cpNetworkGroup, ciscoInterface);
                    AddCheckPointObject(cpNetworkGroup);

                    allInternal.Members.Add(cpNetworkGroup.Name);
                }

                // create host object for the interface's IP address
                var cpHost = new CheckPoint_Host();
                cpHost.Name = ciscoInterface.CiscoId + "_address";
                cpHost.IpAddress = ciscoInterface.IpAddress;
                ApplyConversionIncidentOnCheckPointObject(cpHost, ciscoInterface);
                AddCheckPointObject(cpHost);
            }

            if (ciscoCommandIdWithIncident > 0)
            {
                allInternal.ConversionIncidentType = ConversionIncidentType.ManualActionRequired;
                allInternal.ConvertedCommandId = ciscoCommandIdWithIncident;
            }

            AddCheckPointObject(allInternal);
        }

        private void Add_Zones()
        {
            var aclNames = new List<string>();

            foreach (CiscoCommand command in CiscoAccessGroupCommands)
            {
                var ciscoAccessGroup = (Cisco_AccessGroup)command;
                if (ciscoAccessGroup.Direction == Cisco_AccessGroup.DirectionType.Inbound)
                {
                    if (aclNames.Contains(ciscoAccessGroup.AccessListName))
                    {
                        continue;
                    }
                    aclNames.Add(ciscoAccessGroup.AccessListName);

                    var cpZone = new CheckPoint_Zone();
                    cpZone.Name = CiscoCommand.InterfacePrefix + ciscoAccessGroup.InterfaceName;
                    ApplyConversionIncidentOnCheckPointObject(cpZone, ciscoAccessGroup);
                    AddCheckPointObject(cpZone);
                }
            }

            foreach (CiscoCommand command in CiscoInterfaceCommands)
            {
                var ciscoInterface = (Cisco_Interface)command;
                if (!string.IsNullOrEmpty(ciscoInterface.CiscoId))   // must be interface with a name!!!
                {
                    var cpZone = new CheckPoint_Zone();
                    cpZone.Name = ciscoInterface.CiscoId;
                    cpZone.Comments = "Zone without access-group";
                    ApplyConversionIncidentOnCheckPointObject(cpZone, ciscoInterface);
                    AddCheckPointObject(cpZone);
                }
            }
        }

        private void Add_or_Modify_InterfaceNetworkGroups()
        {
            var interfaceGroupObjects = new List<CheckPoint_NetworkGroup>();

            foreach (CiscoCommand command in CiscoInterfaceCommands)
            {
                var ciscoInterface = (Cisco_Interface)command;
                string interfaceGroupName = ciscoInterface.CiscoId + "_subnets";
                var cpObject = _cpObjects.GetObject(interfaceGroupName);
                if (cpObject != null)
                {
                    interfaceGroupObjects.Add((CheckPoint_NetworkGroup)cpObject);
                }
            }

            var modifiedNetworkGroups = Add_or_Modify_InterfaceNetworkGroups(interfaceGroupObjects);

            // Apply object name verification.
            foreach (var modifiedNetworkGroup in modifiedNetworkGroups)
            {
                if (_cpUnsafeNames.Contains(modifiedNetworkGroup))
                {
                    _cpUnsafeNames.Add(modifiedNetworkGroup + "_include");
                    _cpUnsafeNames.Add(modifiedNetworkGroup + "_exclude");
                }
            }
        }

        private void Add_ServicesAndServiceGroups()
        {
            foreach (CiscoCommand command in CiscoObjectGroupCommands)
            {
                var ciscoGroup = (Cisco_GroupObject)command;

                if (ciscoGroup.GroupType == Cisco_GroupObject.Group_Type.Service)
                {
                    var cpServiceGroup = new CheckPoint_ServiceGroup();
                    cpServiceGroup.Name = ciscoGroup.CiscoId;
                    cpServiceGroup.Comments = ciscoGroup.Description;

                    foreach (string groupName in ciscoGroup.MembersGroupNames)
                    {
                        cpServiceGroup.Members.Add(groupName);
                    }

                    foreach (CiscoCommand ciscoMember in ciscoGroup.MemberObjects)
                    {
                        string cpName;

                        if (ciscoMember.Name() == "service-object")
                        {
                            var ciscoService = (Cisco_ServiceObject)ciscoMember;

                            // Check for the case where we are referencing a service object by its name
                            if (!string.IsNullOrEmpty(ciscoService.RefObjectName))
                            {
                                var ciscoReferencedService = _ciscoParser.GetCommandByCiscoId(ciscoService.RefObjectName);
                                if (ciscoReferencedService != null && _cpObjects.HasObject(ciscoReferencedService.CiscoId))
                                {
                                    cpServiceGroup.Members.Add(ciscoReferencedService.CiscoId);
                                }

                                continue;
                            }

                            switch (ciscoService.Protocol)
                            {
                                case "tcp":
                                    {
                                        cpName = CheckPointServiceObjectsFactory.AutoGeneratedName(_cpObjects,
                                                                                                   ciscoService.Protocol,
                                                                                                   ciscoService.Operator,
                                                                                                   ciscoService.Port,
                                                                                                   ServiceDirection.Destination,
                                                                                                   ciscoService.Id);
                                        if (cpName.Contains(AutoGeneratedNameWithError))
                                        {
                                            ciscoService.ConversionIncidentType = ConversionIncidentType.ManualActionRequired;
                                            ciscoService.ConversionIncidentMessage = "Unrecognized service details: " + ciscoService.Protocol + " " + ciscoService.Operator + " " + ciscoService.Port + ".";
                                        }

                                        var cpTcp = new CheckPoint_TcpService();
                                        cpTcp.Name = cpName;
                                        cpTcp.Port = ciscoService.Port;
                                        ApplyConversionIncidentOnCheckPointObject(cpTcp, ciscoService);
                                        AddCheckPointObject(cpTcp);

                                        cpServiceGroup.Members.Add(cpName);
                                    }
                                    break;

                                case "udp":
                                    {
                                        cpName = CheckPointServiceObjectsFactory.AutoGeneratedName(_cpObjects,
                                                                                                   ciscoService.Protocol,
                                                                                                   ciscoService.Operator,
                                                                                                   ciscoService.Port,
                                                                                                   ServiceDirection.Destination,
                                                                                                   ciscoService.Id);
                                        if (cpName.Contains(AutoGeneratedNameWithError))
                                        {
                                            ciscoService.ConversionIncidentType = ConversionIncidentType.ManualActionRequired;
                                            ciscoService.ConversionIncidentMessage = "Unrecognized service details: " + ciscoService.Protocol + " " + ciscoService.Operator + " " + ciscoService.Port + ".";
                                        }

                                        var cpUdp = new CheckPoint_UdpService();
                                        cpUdp.Name = cpName;
                                        cpUdp.Port = ciscoService.Port;
                                        ApplyConversionIncidentOnCheckPointObject(cpUdp, ciscoService);
                                        AddCheckPointObject(cpUdp);

                                        cpServiceGroup.Members.Add(cpName);
                                    }
                                    break;

                                case "tcp-udp":
                                    {
                                        cpName = CheckPointServiceObjectsFactory.AutoGeneratedName(_cpObjects,
                                                                                                   ProtocolType.Tcp,
                                                                                                   TcpUdpPortOperatorType.Eq,
                                                                                                   ciscoService.Port,
                                                                                                   ServiceDirection.Destination,
                                                                                                   ciscoService.Id);
                                        if (cpName.Contains(AutoGeneratedNameWithError))
                                        {
                                            ciscoService.ConversionIncidentType = ConversionIncidentType.ManualActionRequired;
                                            ciscoService.ConversionIncidentMessage = "Unrecognized service details: tcp eq " + ciscoService.Port + ".";
                                        }

                                        var cpTcp = new CheckPoint_TcpService();
                                        cpTcp.Name = cpName;
                                        cpTcp.Port = ciscoService.Port;
                                        ApplyConversionIncidentOnCheckPointObject(cpTcp, ciscoService);
                                        AddCheckPointObject(cpTcp);

                                        cpServiceGroup.Members.Add(cpName);

                                        cpName = CheckPointServiceObjectsFactory.AutoGeneratedName(_cpObjects,
                                                                                                   ProtocolType.Udp,
                                                                                                   TcpUdpPortOperatorType.Eq,
                                                                                                   ciscoService.Port,
                                                                                                   ServiceDirection.Destination,
                                                                                                   ciscoService.Id);
                                        if (cpName.Contains(AutoGeneratedNameWithError))
                                        {
                                            ciscoService.ConversionIncidentType = ConversionIncidentType.ManualActionRequired;
                                            ciscoService.ConversionIncidentMessage = "Unrecognized service details: udp eq " + ciscoService.Port + ".";
                                        }

                                        var cpUdp = new CheckPoint_UdpService();
                                        cpUdp.Name = cpName;
                                        cpUdp.Port = ciscoService.Port;
                                        ApplyConversionIncidentOnCheckPointObject(cpUdp, ciscoService);
                                        AddCheckPointObject(cpUdp);

                                        cpServiceGroup.Members.Add(cpName);
                                    }
                                    break;

                                case "icmp":
                                    cpName = CheckPointServiceObjectsFactory.AutoGeneratedName(_cpObjects,
                                                                                               ProtocolType.Icmp,
                                                                                               TcpUdpPortOperatorType.Eq,
                                                                                               ciscoService.Port,
                                                                                               ServiceDirection.Destination,
                                                                                               ciscoService.Id);
                                    cpServiceGroup.Members.Add(cpName);

                                    if (cpName == "icmp-proto" && !string.IsNullOrEmpty(ciscoService.Port))
                                    {
                                        ciscoService.ConversionIncidentType = ConversionIncidentType.Informative;
                                        ciscoGroup.ConversionIncidentType = ConversionIncidentType.Informative;
                                        ciscoGroup.ConversionIncidentMessage = "Unrecognized ICMP service type: " + ciscoService.Port + ". Using generic icmp-proto service";
                                    }
                                    break;

                                case "ip":
                                    if (ciscoGroup.MemberObjects.Count > 1)
                                    {
                                        ciscoService.ConversionIncidentType = ConversionIncidentType.Informative;
                                        ciscoGroup.ConversionIncidentType = ConversionIncidentType.Informative;
                                        ciscoGroup.ConversionIncidentMessage = "Ignoring service group member: generic IP protocol service.";
                                    }
                                    break;

                                default:
                                    // No need to check also for CiscoKnownServices.IsKnownServiceNumber here, 
                                    // because it is already done in Cisco_ServiceObject class!!!
                                    if (CiscoKnownServices.IsKnownService(ciscoService.Protocol))
                                    {
                                        var cpOtherService = CheckPointServiceObjectsFactory.CreateServiceObj(_cpObjects,
                                                                                                              ProtocolType.KnownOtherIpProtocol,
                                                                                                              TcpUdpPortOperatorType.NA,
                                                                                                              ciscoService.Protocol,
                                                                                                              ServiceDirection.Destination,
                                                                                                              ciscoService.Id);
                                        if (cpOtherService != null && cpOtherService.GetType() == typeof(CheckPoint_OtherService))
                                        {
                                            ApplyConversionIncidentOnCheckPointObject(cpOtherService, ciscoService);
                                            AddCheckPointObject(cpOtherService);

                                            cpServiceGroup.Members.Add(cpOtherService.Name);
                                        }
                                    }
                                    else
                                    {
                                        ciscoService.ConversionIncidentType = ConversionIncidentType.ManualActionRequired;
                                        ciscoGroup.ConversionIncidentType = ConversionIncidentType.ManualActionRequired;
                                        ciscoGroup.ConversionIncidentMessage = "Error in member service: Unrecognized service protocol (" + ciscoService.Protocol + ")";
                                    }
                                    break;
                            }
                        }

                        if (ciscoMember.Name() == "port-object")
                        {
                            var ciscoPort = (Cisco_PortObject)ciscoMember;

                            switch (ciscoGroup.ServiceProtocol)
                            {
                                case "tcp":
                                    {
                                        cpName = CheckPointServiceObjectsFactory.AutoGeneratedName(_cpObjects,
                                                                                                   ProtocolType.Tcp,
                                                                                                   TcpUdpPortOperatorType.Eq,
                                                                                                   ciscoPort.Port,
                                                                                                   ServiceDirection.Destination,
                                                                                                   ciscoPort.Id);
                                        if (cpName.Contains(AutoGeneratedNameWithError))
                                        {
                                            ciscoPort.ConversionIncidentType = ConversionIncidentType.ManualActionRequired;
                                            ciscoPort.ConversionIncidentMessage = "Unrecognized service details: " + ciscoGroup.ServiceProtocol + " eq " + ciscoPort.Port + ".";
                                        }

                                        var cpTcp = new CheckPoint_TcpService();
                                        cpTcp.Name = cpName;
                                        cpTcp.Port = CiscoKnownServices.ConvertServiceToPort(ciscoPort.Port);
                                        ApplyConversionIncidentOnCheckPointObject(cpTcp, ciscoPort);
                                        AddCheckPointObject(cpTcp);

                                        cpServiceGroup.Members.Add(cpName);
                                    }
                                    break;

                                case "udp":
                                    {
                                        cpName = CheckPointServiceObjectsFactory.AutoGeneratedName(_cpObjects,
                                                                                                   ProtocolType.Udp,
                                                                                                   TcpUdpPortOperatorType.Eq,
                                                                                                   ciscoPort.Port,
                                                                                                   ServiceDirection.Destination,
                                                                                                   ciscoPort.Id);
                                        if (cpName.Contains(AutoGeneratedNameWithError))
                                        {
                                            ciscoPort.ConversionIncidentType = ConversionIncidentType.ManualActionRequired;
                                            ciscoPort.ConversionIncidentMessage = "Unrecognized service details: " + ciscoGroup.ServiceProtocol + " eq " + ciscoPort.Port + ".";
                                        }

                                        var cpUdp = new CheckPoint_UdpService();
                                        cpUdp.Name = cpName;
                                        cpUdp.Port = CiscoKnownServices.ConvertServiceToPort(ciscoPort.Port);
                                        ApplyConversionIncidentOnCheckPointObject(cpUdp, ciscoPort);
                                        AddCheckPointObject(cpUdp);

                                        cpServiceGroup.Members.Add(cpName);
                                    }
                                    break;

                                case "tcp-udp":
                                    {
                                        cpName = CheckPointServiceObjectsFactory.AutoGeneratedName(_cpObjects,
                                                                                                   ProtocolType.Tcp,
                                                                                                   TcpUdpPortOperatorType.Eq,
                                                                                                   ciscoPort.Port,
                                                                                                   ServiceDirection.Destination,
                                                                                                   ciscoPort.Id);
                                        if (cpName.Contains(AutoGeneratedNameWithError))
                                        {
                                            ciscoPort.ConversionIncidentType = ConversionIncidentType.ManualActionRequired;
                                            ciscoPort.ConversionIncidentMessage = "Unrecognized service details: tcp eq " + ciscoPort.Port + ".";
                                        }

                                        var cpTcp = new CheckPoint_TcpService();
                                        cpTcp.Name = cpName;
                                        cpTcp.Port = CiscoKnownServices.ConvertServiceToPort(ciscoPort.Port);
                                        ApplyConversionIncidentOnCheckPointObject(cpTcp, ciscoPort);
                                        AddCheckPointObject(cpTcp);

                                        cpServiceGroup.Members.Add(cpName);

                                        cpName = CheckPointServiceObjectsFactory.AutoGeneratedName(_cpObjects,
                                                                                                   ProtocolType.Udp,
                                                                                                   TcpUdpPortOperatorType.Eq,
                                                                                                   ciscoPort.Port,
                                                                                                   ServiceDirection.Destination,
                                                                                                   ciscoPort.Id);
                                        if (cpName.Contains(AutoGeneratedNameWithError))
                                        {
                                            ciscoPort.ConversionIncidentType = ConversionIncidentType.ManualActionRequired;
                                            ciscoPort.ConversionIncidentMessage = "Unrecognized service details: udp eq " + ciscoPort.Port + ".";
                                        }

                                        var cpUdp = new CheckPoint_UdpService();
                                        cpUdp.Name = cpName;
                                        cpUdp.Port = CiscoKnownServices.ConvertServiceToPort(ciscoPort.Port);
                                        ApplyConversionIncidentOnCheckPointObject(cpUdp, ciscoPort);
                                        AddCheckPointObject(cpUdp);

                                        cpServiceGroup.Members.Add(cpName);
                                    }
                                    break;
                            }
                        }
                    }

                    ApplyConversionIncidentOnCheckPointObject(cpServiceGroup, ciscoGroup);
                    CheckObjectNameValidity(cpServiceGroup, ciscoGroup);
                    AddCheckPointObject(cpServiceGroup);
                }
            }

            foreach (CiscoCommand command in CiscoAclCommands)
            {
                var ciscoAcl = (Cisco_AccessList)command;
                if (ciscoAcl.IsRemark)
                {
                    continue;
                }

                if (ciscoAcl.SourceProperties != null)
                {
                    CheckPointObject cpSourceService = CheckPointServiceObjectsFactory.CreateServiceObj(_cpObjects,
                                                                                                        ciscoAcl.SourceProperties.Protocol,
                                                                                                        ciscoAcl.SourceProperties.TcpUdpPortOperator,
                                                                                                        ciscoAcl.SourceProperties.TcpUdpPortValue,
                                                                                                        ServiceDirection.Source,
                                                                                                        ciscoAcl.Id);
                    if (cpSourceService != null &&
                        (cpSourceService.GetType() == typeof(CheckPoint_TcpService) || cpSourceService.GetType() == typeof(CheckPoint_UdpService) || cpSourceService.GetType() == typeof(CheckPoint_OtherService)))
                    {
                        ApplyConversionIncidentOnCheckPointObject(cpSourceService, ciscoAcl);
                        AddCheckPointObject(cpSourceService);
                    }
                }

                if (ciscoAcl.DestinationProperties != null)
                {
                    CheckPointObject cpDestService = CheckPointServiceObjectsFactory.CreateServiceObj(_cpObjects,
                                                                                                      ciscoAcl.DestinationProperties.Protocol,
                                                                                                      ciscoAcl.DestinationProperties.TcpUdpPortOperator,
                                                                                                      ciscoAcl.DestinationProperties.TcpUdpPortValue,
                                                                                                      ServiceDirection.Destination,
                                                                                                      ciscoAcl.Id);
                    if (cpDestService != null &&
                        (cpDestService.GetType() == typeof(CheckPoint_TcpService) || cpDestService.GetType() == typeof(CheckPoint_UdpService) || cpDestService.GetType() == typeof(CheckPoint_OtherService)))
                    {
                        ApplyConversionIncidentOnCheckPointObject(cpDestService, ciscoAcl);
                        AddCheckPointObject(cpDestService);
                    }
                }
            }
        }

        private void Add_TimeRanges()
        {
            IEnumerable<CiscoCommand> caTimesList = CisciTimeRangeCommands;

            const int cpTimeRangeNameLength = 11;

            List<string> cpTimeRangesNamesUniq = new List<string>();
            int cpTimeNamePostfixInt = 1;

            foreach (CiscoCommand command in caTimesList)
            {
                if (command.GetType() == typeof(Cisco_TimeRange))
                {
                    Cisco_TimeRange caTime = (Cisco_TimeRange)command;

                    string cpTimeRangeNameSrc = caTime.TimeRangeName;

                    if (caTime.PeriodicsList != null && caTime.PeriodicsList.Count > 1)
                    {
                        int postfixIndex = 1;
                        bool isRenamed = false;
                        foreach (string periodic in caTime.PeriodicsList)
                        {
                            string postfixString = "_" + postfixIndex++;
                            string cpTimeRangeName = cpTimeRangeNameSrc + postfixString;

                            while (cpTimeRangeName.Length > cpTimeRangeNameLength || cpTimeRangesNamesUniq.Contains(cpTimeRangeName))
                            {
                                string cpTimeNamePostfixStr = "_" + cpTimeNamePostfixInt;
                                cpTimeRangeName = cpTimeRangeNameSrc.Substring(0, cpTimeRangeNameLength - cpTimeNamePostfixStr.Length - postfixString.Length);
                                cpTimeRangeName = cpTimeRangeName + cpTimeNamePostfixStr + postfixString;
                                isRenamed = true;
                            }

                            Add_TimeRange(caTime.Id, caTime.TimeRangeName, cpTimeRangeName, caTime.StartDateTime, caTime.EndDateTime, periodic);
                            cpTimeRangesNamesUniq.Add(cpTimeRangeName);
                        }

                        if (isRenamed)
                            cpTimeNamePostfixInt += 1;
                    }
                    else
                    {
                        while (cpTimeRangeNameSrc.Length > cpTimeRangeNameLength || cpTimeRangesNamesUniq.Contains(cpTimeRangeNameSrc))
                        {
                            string cpTimeNamePostfixStr = "_" + cpTimeNamePostfixInt;
                            cpTimeRangeNameSrc = cpTimeRangeNameSrc.Substring(0, cpTimeRangeNameLength - cpTimeNamePostfixStr.Length);
                            cpTimeRangeNameSrc = cpTimeRangeNameSrc + cpTimeNamePostfixStr;
                            cpTimeNamePostfixInt += 1;
                        }

                        string periodic = null;
                        if (caTime.PeriodicsList.Count == 1)
                        {
                            periodic = caTime.PeriodicsList[0];
                        }
                        Add_TimeRange(caTime.Id, caTime.TimeRangeName, cpTimeRangeNameSrc, caTime.StartDateTime, caTime.EndDateTime, periodic);
                        cpTimeRangesNamesUniq.Add(cpTimeRangeNameSrc);
                    }
                }
            }
        }

        private void Add_TimeRange(int caTimeId, string caTimeRangeName, string cpTimeRangeName, string cpStartDateTime, string cpEndDateTime, string period = null)
        {
            if (!caTimeRangeName.Equals(cpTimeRangeName))
            {
                _conversionIncidents.Add(
                    new ConversionIncident(
                        caTimeId,
                        "TITLE: object is renamed",
                        "DESCRIPTION: object renamed from " + caTimeRangeName + " to " + cpTimeRangeName,
                        ConversionIncidentType.Informative));
            }

            CheckPoint_Time cpTime = new CheckPoint_Time();
            cpTime.Name = cpTimeRangeName;
            cpTime.Comments = "Old Time Object name: " + caTimeRangeName;
            cpTime.StartNow = true;
            cpTime.EndNever = true;

            if (cpStartDateTime != null) // check if Cisco has Start Time
            {
                cpTime.StartNow = false;

                DateTime date = DateTime.ParseExact(cpStartDateTime, "HH:mm dd MMMM yyyy", CultureInfo.InvariantCulture);
                cpTime.StartDate = date.ToString("dd-MMM-yyyy", CultureInfo.InvariantCulture).Trim();
                cpTime.StartTime = date.ToString("HH:mm").Trim();
            }

            if (cpEndDateTime != null)
            {
                cpTime.EndNever = false;

                DateTime date = DateTime.ParseExact(cpEndDateTime, "HH:mm dd MMMM yyyy", CultureInfo.InvariantCulture);
                cpTime.EndDate = date.ToString("dd-MMM-yyyy", CultureInfo.InvariantCulture).Trim();
                cpTime.EndTime = date.ToString("HH:mm").Trim();
            }


            if (period != null)
            {
                string[] times = null;

                if (period.StartsWith("daily"))
                {
                    times = period.Trim().Substring("daily".Length).Trim().Split(new string[] { "to" }, StringSplitOptions.RemoveEmptyEntries);

                    cpTime.RecurrencePattern = CheckPoint_Time.RecurrencePatternEnum.Daily;
                }
                else
                {
                    cpTime.RecurrencePattern = CheckPoint_Time.RecurrencePatternEnum.Weekly;

                    if (period.StartsWith("weekdays"))
                    {
                        cpTime.RecurrenceWeekdays.Add(CheckPoint_Time.Weekdays.Mon);
                        cpTime.RecurrenceWeekdays.Add(CheckPoint_Time.Weekdays.Tue);
                        cpTime.RecurrenceWeekdays.Add(CheckPoint_Time.Weekdays.Wed);
                        cpTime.RecurrenceWeekdays.Add(CheckPoint_Time.Weekdays.Thu);
                        cpTime.RecurrenceWeekdays.Add(CheckPoint_Time.Weekdays.Fri);

                        times = period.Trim().Substring("weekdays".Length).Trim().Split(new string[] { "to" }, StringSplitOptions.RemoveEmptyEntries);
                    }
                    else if (period.StartsWith("weekend"))
                    {
                        cpTime.RecurrenceWeekdays.Add(CheckPoint_Time.Weekdays.Sat);
                        cpTime.RecurrenceWeekdays.Add(CheckPoint_Time.Weekdays.Sun);

                        times = period.Trim().Substring("weekend".Length).Trim().Split(new string[] { "to" }, StringSplitOptions.RemoveEmptyEntries);
                    }
                    else
                    {
                        string[] daysTimes = period.Trim().Split(new string[] { "to" }, StringSplitOptions.RemoveEmptyEntries);

                        string[] daysTimes_1 = daysTimes[0].Split(new string[] { " " }, StringSplitOptions.RemoveEmptyEntries);
                        string[] daysTimes_2 = daysTimes[1].Split(new string[] { " " }, StringSplitOptions.RemoveEmptyEntries);

                        if (daysTimes_1.Length == 2 && daysTimes_2.Length == 2)
                        {
                            int startWdIndex = (int)WeekDayFromCiscoToCP(daysTimes_1[0]);
                            int endWdIndex = (int)WeekDayFromCiscoToCP(daysTimes_2[0]);

                            if (startWdIndex < endWdIndex)
                            {
                                for (int i = startWdIndex; i <= endWdIndex; i++)
                                {
                                    cpTime.RecurrenceWeekdays.Add((CheckPoint_Time.Weekdays)i);
                                }
                            }
                            else
                            {
                                int firstWdIndex = (int)Enum.GetValues(typeof(CheckPoint_Time.Weekdays)).Cast<CheckPoint_Time.Weekdays>().First();
                                int lastWdIndex = (int)Enum.GetValues(typeof(CheckPoint_Time.Weekdays)).Cast<CheckPoint_Time.Weekdays>().Last();

                                for (int i = firstWdIndex; i <= endWdIndex; i++)
                                {
                                    cpTime.RecurrenceWeekdays.Add((CheckPoint_Time.Weekdays)i);
                                }

                                for (int i = startWdIndex; i <= lastWdIndex; i++)
                                {
                                    cpTime.RecurrenceWeekdays.Add((CheckPoint_Time.Weekdays)i);
                                }
                            }

                            times = new string[] { daysTimes_1[daysTimes_1.Length - 1], daysTimes_2[daysTimes_2.Length - 1] };
                        }
                        else if (daysTimes_2.Length == 1)
                        {
                            for (int i = 0; i < daysTimes_1.Length - 1; i++)
                            {
                                cpTime.RecurrenceWeekdays.Add(WeekDayFromCiscoToCP(daysTimes_1[i]));
                            }

                            times = new string[] { daysTimes_1[daysTimes_1.Length - 1], daysTimes_2[0] };
                        }
                        else
                        {
                            throw new IOException("Invalid periodic pattern");
                        }
                    }
                }

                TimeSpan timeCheck0 = TimeSpan.ParseExact(times[0].Trim(), "h\\:mm", CultureInfo.InvariantCulture);
                TimeSpan timeCheck1 = TimeSpan.ParseExact(times[1].Trim(), "h\\:mm", CultureInfo.InvariantCulture);

                if (TimeSpan.Compare(timeCheck0, timeCheck1) == -1)
                {
                    cpTime.HoursRangesEnabled_1 = true;
                    cpTime.HoursRangesFrom_1 = times[0].Trim();
                    cpTime.HoursRangesTo_1 = times[1].Trim();
                }
                else
                {
                    cpTime.HoursRangesEnabled_1 = true;
                    cpTime.HoursRangesFrom_1 = times[0].Trim();
                    cpTime.HoursRangesTo_1 = "23:59".Trim();

                    cpTime.HoursRangesEnabled_2 = true;
                    cpTime.HoursRangesFrom_2 = "00:00".Trim();
                    cpTime.HoursRangesTo_2 = times[1].Trim();
                }
            }

            AddCheckPointObject(cpTime);

            List<string> cpTimeNamesList = null;
            _ciscoTimeNamesToCpTimeNamesDict.TryGetValue(caTimeRangeName, out cpTimeNamesList);
            if (cpTimeNamesList == null)
            {
                cpTimeNamesList = new List<string>();
            }
            cpTimeNamesList.Add(cpTime.Name);
            _ciscoTimeNamesToCpTimeNamesDict[caTimeRangeName] = cpTimeNamesList;
        }

        private CheckPoint_Time.Weekdays WeekDayFromCiscoToCP(string weekDayCisco)
        {
            CheckPoint_Time.Weekdays weekDayCP;
            switch (weekDayCisco)
            {
                case "Monday": weekDayCP = CheckPoint_Time.Weekdays.Mon; break;
                case "Tuesday": weekDayCP = CheckPoint_Time.Weekdays.Tue; break;
                case "Wednesday": weekDayCP = CheckPoint_Time.Weekdays.Wed; break;
                case "Thursday": weekDayCP = CheckPoint_Time.Weekdays.Thu; break;
                case "Friday": weekDayCP = CheckPoint_Time.Weekdays.Fri; break;
                case "Saturday": weekDayCP = CheckPoint_Time.Weekdays.Sat; break;
                default: weekDayCP = CheckPoint_Time.Weekdays.Sun; break;
            }

            return weekDayCP;
        }

        private void Add_Package()
        {
            var cpPackage = new CheckPoint_Package();
            cpPackage.Name = _policyPackageName;

            // add parent layer
            Add_ParentLayer(cpPackage);

            // add sub-policies
            Add_Layers_And_Rules(cpPackage);

            // add sub-policies for zones without access-groups
            Add_Layers_And_Rules_For_Other_Zones(cpPackage);

            // add global rules to every sub-policy
            Add_Global_Rules(cpPackage);

            DetectCheckPointFirewallRulesAffectedByInspectPolicy(cpPackage);

            AddCheckPointObject(cpPackage);
        }

        private void Add_ParentLayer(CheckPoint_Package package)
        {
            package.ParentLayer.Name = package.NameOfAccessLayer;

            // Add rules to parent layer due to Cisco SSH OS commands for firewall control and management.
            // These rules must be the topmost rules!!!
            if (CiscoSshCommands.Count > 0 && CiscoHostnameCommand != null)
            {
                // Create a destination simple gateway object
                string gwIpAddress = "1.1.1.1";

                var ciscoInterfaceObject = _ciscoParser.GetCommandByCiscoId(CiscoCommand.InterfacePrefix + "Management");
                if (ciscoInterfaceObject != null && ciscoInterfaceObject.GetType() == typeof(Cisco_Interface))
                {
                    var ciscoInterface = (Cisco_Interface)ciscoInterfaceObject;
                    if (ciscoInterface.HasValidIpAddress())
                    {
                        gwIpAddress = ciscoInterface.IpAddress;
                    }
                }

                var cpSimpleGw = new CheckPoint_SimpleGateway();
                cpSimpleGw.Name = CiscoHostnameCommand.HostName;
                cpSimpleGw.IpAddress = gwIpAddress;
                AddCheckPointObject(cpSimpleGw);

                // Create a collection of SSH hosts/networks as a source for the rules
                var sshHosts = new List<CheckPointObject>();
                foreach (CiscoCommand command in CiscoSshCommands)
                {
                    var ssh = (Cisco_SSH)command;
                    var sshHost = new CiscoNetwork(command.Id, ssh.IpAddress, ssh.Netmask);

                    if (sshHost.IsHost())
                    {
                        var cpHost = new CheckPoint_Host();
                        cpHost.Name = sshHost.AutoGeneratedName();
                        cpHost.IpAddress = sshHost.IpAddress;
                        cpHost.ConvertedCommandId = sshHost.CiscoCommandId;
                        AddCheckPointObject(cpHost);

                        sshHosts.Add(cpHost);
                    }
                    else if (sshHost.IsNetwork())
                    {
                        var cpNetwork = new CheckPoint_Network();
                        cpNetwork.Name = sshHost.AutoGeneratedName();
                        cpNetwork.Subnet = sshHost.IpAddress;
                        cpNetwork.Netmask = sshHost.NetMask;
                        cpNetwork.ConvertedCommandId = sshHost.CiscoCommandId;
                        AddCheckPointObject(cpNetwork);

                        sshHosts.Add(cpNetwork);
                    }
                }

                // First rule: SSH access to the Firewall
                var cpRule = new CheckPoint_Rule();
                cpRule.Name = "SSH access to the Firewall";
                cpRule.Source.AddRange(sshHosts);
                cpRule.Destination.Add(cpSimpleGw);
                cpRule.Service.Add(_cpObjects.GetObject("ssh_version_2"));
                cpRule.Action = CheckPoint_Rule.ActionType.Accept;
                cpRule.Layer = package.NameOfAccessLayer;
                cpRule.ConversionComments = "Firewall control and management";

                package.ParentLayer.Rules.Add(cpRule);

                // Second rule: SSH access to the WebUI
                cpRule = new CheckPoint_Rule();
                cpRule.Name = "Allow access to the WebUI";
                cpRule.Source.AddRange(sshHosts);
                cpRule.Destination.Add(cpSimpleGw);
                cpRule.Service.Add(_cpObjects.GetObject("https"));
                cpRule.Action = CheckPoint_Rule.ActionType.Accept;
                cpRule.Enabled = false;   // !!!
                cpRule.Layer = package.NameOfAccessLayer;
                cpRule.ConversionComments = "Firewall control and management";

                package.ParentLayer.Rules.Add(cpRule);

                // Third rule: Stealth Rule
                cpRule = new CheckPoint_Rule();
                cpRule.Name = "Stealth Rule";
                cpRule.Destination.Add(cpSimpleGw);
                cpRule.Action = CheckPoint_Rule.ActionType.Drop;
                cpRule.Layer = package.NameOfAccessLayer;
                cpRule.ConversionComments = "Firewall control and management";

                package.ParentLayer.Rules.Add(cpRule);
            }

            // Add parent rules for interfaces used in access-groups
            var accessGroups = new List<string>();
            var accessGroupsExclude = new List<string>();
            var aclNames = new List<string>();

            foreach (CiscoCommand command in CiscoAccessGroupCommands)
            {
                var ciscoAccessGroup = (Cisco_AccessGroup)command;
                if (ciscoAccessGroup.Direction == Cisco_AccessGroup.DirectionType.Inbound)
                {
                    if (aclNames.Contains(ciscoAccessGroup.AccessListName))
                    {
                        continue;
                    }
                    aclNames.Add(ciscoAccessGroup.AccessListName);

                    accessGroups.Add(CiscoCommand.InterfacePrefix + ciscoAccessGroup.InterfaceName);

                    // get Cisco interface object
                    var ciscoInterface = (Cisco_Interface)_ciscoParser.GetCommandByCiscoId(CiscoCommand.InterfacePrefix + ciscoAccessGroup.InterfaceName);
                    if (ciscoInterface == null || !ciscoInterface.HasValidIpAddress())
                    {
                        continue;
                    }

                    // This cpObject is supposed to be a CheckPoint_Zone object, unless there was an error...
                    var cpObject = GetCheckPointObjectOrCreateDummy(CiscoCommand.InterfacePrefix + ciscoAccessGroup.InterfaceName,
                                                                    CheckPointDummyObjectType.NetworkGroup,
                                                                    ciscoAccessGroup,
                                                                    "Error creating a parent layer rule, missing topology information for Cisco interface",
                                                                    "Interface details: " + ciscoAccessGroup.InterfaceName + ".");

                    var cpRule = new CheckPoint_Rule();
                    cpRule.Source.Add(cpObject);
                    cpRule.Action = CheckPoint_Rule.ActionType.SubPolicy;
                    cpRule.SubPolicyName = ciscoAccessGroup.AccessListName;
                    cpRule.Layer = package.NameOfAccessLayer;
                    ApplyConversionIncidentOnCheckPointObject(cpRule, ciscoAccessGroup);

                    package.ParentLayer.Rules.Add(cpRule);
                }
                else
                {
                    // No Outbound nor Global...
                    accessGroupsExclude.Add(CiscoCommand.InterfacePrefix + ciscoAccessGroup.InterfaceName);
                }
            }

            // Add parent rules for interfaces without access-groups
            var availableZones = new List<CheckPoint_Zone>();
            int availableZonesWithZeroSecurityLevel = 0;

            foreach (CheckPoint_Zone cpZone in _cpZones)
            {
                if (accessGroups.Contains(cpZone.Name) || accessGroupsExclude.Contains(cpZone.Name))
                {
                    continue;
                }

                // get Cisco interface object
                var ciscoInterface = (Cisco_Interface)_ciscoParser.GetCommandByCiscoId(cpZone.Name);
                if (ciscoInterface == null || !ciscoInterface.HasValidIpAddress() || ciscoInterface.ManagementOnly)
                {
                    continue;
                }

                availableZones.Add(cpZone);

                // If the _isInterInterfaceTrafficAllowed flag is on and there are at least two Cisco interfaces with zero security level, 
                // we should add parent rules for the equivalent CP zones to allow traffic between them.
                if (ciscoInterface.SecurityLevel == 0)
                {
                    ++availableZonesWithZeroSecurityLevel;
                }
            }

            foreach (CheckPoint_Zone cpZone in availableZones)
            {
                // get Cisco interface object
                var ciscoInterface = (Cisco_Interface)_ciscoParser.GetCommandByCiscoId(cpZone.Name);

                bool addParentRule = (_isIntraInterfaceTrafficAllowed || (_isInterInterfaceTrafficAllowed && availableZonesWithZeroSecurityLevel >= 2))
                                         ? (ciscoInterface.SecurityLevel >= 0)
                                         : (ciscoInterface.SecurityLevel > 0);

                if (addParentRule)
                {
                    var cpRule = new CheckPoint_Rule();
                    cpRule.Source.Add(cpZone);
                    cpRule.Action = CheckPoint_Rule.ActionType.SubPolicy;
                    cpRule.SubPolicyName = cpZone.Name + "_sub_policy";
                    cpRule.Layer = package.NameOfAccessLayer;
                    cpRule.ConversionComments = "Cisco zone with security-level " + ciscoInterface.SecurityLevel;
                    ApplyConversionIncidentOnCheckPointObject(cpRule, ciscoInterface);

                    package.ParentLayer.Rules.Add(cpRule);
                }
            }

            // Add cleanup rule
            var cpCleanupRule = new CheckPoint_Rule();
            cpCleanupRule.Name = "Cleanup rule";
            cpCleanupRule.Action = CheckPoint_Rule.ActionType.Drop;
            cpCleanupRule.Layer = package.NameOfAccessLayer;

            package.ParentLayer.Rules.Add(cpCleanupRule);
        }

        private void Add_Layers_And_Rules(CheckPoint_Package package)
        {
            var aclNames = new List<string>();

            foreach (CiscoCommand command in CiscoAccessGroupCommands)
            {
                var ciscoAccessGroup = (Cisco_AccessGroup)command;

                if (aclNames.Contains(ciscoAccessGroup.AccessListName))
                {
                    continue;
                }

                if (ciscoAccessGroup.Direction != Cisco_AccessGroup.DirectionType.Inbound && ciscoAccessGroup.Direction != Cisco_AccessGroup.DirectionType.Global)
                {
                    ciscoAccessGroup.ConversionIncidentType = ConversionIncidentType.Informative;

                    _conversionIncidents.Add(new ConversionIncident(ciscoAccessGroup.Id,
                                                                    "Not converting outbound ACL groups",
                                                                    "All related ACLs are skipped.",
                                                                    ciscoAccessGroup.ConversionIncidentType));

                    continue;
                }

                aclNames.Add(ciscoAccessGroup.AccessListName);

                if (ciscoAccessGroup.Direction == Cisco_AccessGroup.DirectionType.Global)
                {
                    foreach (CiscoCommand aclCommand in CiscoAclCommands)
                    {
                        var ciscoAcl = (Cisco_AccessList)aclCommand;
                        if (!ciscoAcl.IsRemark && ciscoAcl.ACLName == ciscoAccessGroup.AccessListName)
                        {
                            _ciscoGlobalAclCommands.Add(ciscoAcl);
                        }
                    }
                }
                else   // Inbound
                {
                    // get Cisco interface object
                    var ciscoInterface = (Cisco_Interface)_ciscoParser.GetCommandByCiscoId(CiscoCommand.InterfacePrefix + ciscoAccessGroup.InterfaceName);
                    if (ciscoInterface == null)
                    {
                        ciscoAccessGroup.ConversionIncidentType = ConversionIncidentType.ManualActionRequired;

                        _conversionIncidents.Add(new ConversionIncident(ciscoAccessGroup.Id,
                                                                        "Cannot find interface assigned to ACL group",
                                                                        "Interface details: " + ciscoAccessGroup.InterfaceName + ".",
                                                                        ciscoAccessGroup.ConversionIncidentType));

                        continue;
                    }
                    if (!ciscoInterface.HasValidIpAddress())
                    {
                        ciscoAccessGroup.ConversionIncidentType = ConversionIncidentType.Informative;

                        _conversionIncidents.Add(new ConversionIncident(ciscoAccessGroup.Id,
                                                                        "Not processing ACL groups that reference an interface without IP address",
                                                                        "All ACLs related to interface " + ciscoAccessGroup.InterfaceName + " are skipped.",
                                                                        ciscoAccessGroup.ConversionIncidentType));

                        continue;
                    }

                    var cpLayer = new CheckPoint_Layer();
                    cpLayer.Name = ciscoAccessGroup.AccessListName;
                    cpLayer.Comments = ciscoAccessGroup.Description;

                    if (ciscoInterface.Shutdown)
                    {
                        cpLayer.Tag = "InterfaceDisabled";
                    }

                    // Automatic rule is added for management-only interface:
                    if (ciscoInterface.ManagementOnly && CiscoHostnameCommand != null)
                    {
                        var cpRule = new CheckPoint_Rule();
                        cpRule.Enabled = true;
                        cpRule.Layer = ciscoAccessGroup.AccessListName;
                        cpRule.Source.Add(_cpObjects.GetObject(CheckPointObject.Any));
                        cpRule.Destination.Add(_cpObjects.GetObject(CiscoHostnameCommand.HostName));
                        cpRule.DestinationNegated = true;
                        cpRule.Service.Add(_cpObjects.GetObject(CheckPointObject.Any));
                        cpRule.Action = CheckPoint_Rule.ActionType.Drop;
                        cpRule.ConversionComments = "Automatic rule for management-only interface";

                        cpLayer.Rules.Add(cpRule);
                    }

                    foreach (CiscoCommand aclCommand in CiscoAclCommands)
                    {
                        var ciscoAcl = (Cisco_AccessList)aclCommand;
                        if (!ciscoAcl.IsRemark && ciscoAcl.ACLName == ciscoAccessGroup.AccessListName)
                        {
                            var cpRule = Acl_To_CPRule(ciscoAcl, null);

                            if (ciscoInterface.Shutdown)
                            {
                                cpRule.Enabled = false;
                            }

                            cpLayer.Rules.Add(cpRule);

                            if (cpRule.ConversionIncidentType != ConversionIncidentType.None || ciscoAcl.ConversionIncidentType != ConversionIncidentType.None)
                            {
                                package.ConversionIncidentType = ConversionIncidentType.Informative;
                            }
                        }
                    }

                    // Do NOT create a cleanup rule if it already exists
                    bool createCleanupRule = true;
                    if (cpLayer.Rules.Count > 0)
                    {
                        var lastRule = cpLayer.Rules[cpLayer.Rules.Count - 1];
                        createCleanupRule = !lastRule.IsCleanupRule();
                    }

                    if (createCleanupRule)
                    {
                        var cpCleanupRule = new CheckPoint_Rule();
                        cpCleanupRule.Name = CheckPoint_Rule.SubPolicyCleanupRuleName;
                        cpCleanupRule.Action = CheckPoint_Rule.ActionType.Drop;
                        cpCleanupRule.Layer = cpLayer.Name;

                        cpLayer.Rules.Add(cpCleanupRule);
                    }

                    package.SubPolicies.Add(cpLayer);
                    validatePackage(package);
                }
            }
        }

        private void Add_Global_Rules(CheckPoint_Package package)
        {
            if (_ciscoGlobalAclCommands.Count > 0)
            {
                // remove clenup rule of each sublayer if global rules exist because cleanup rule should be added after global-rules                
                foreach (var subpolicy in package.SubPolicies)
                {
                    if (subpolicy.Rules.Count > 0)
                    {
                        var lastRule = subpolicy.Rules[subpolicy.Rules.Count - 1];
                        if (lastRule.IsCleanupRule())
                            subpolicy.Rules.Remove(lastRule);
                    }
                }

                //remove cleanup rule of parent layer because it will be added after global rules
                if (package.ParentLayer.Rules.Count > 0)
                {
                    var lastRule = package.ParentLayer.Rules[package.ParentLayer.Rules.Count - 1];
                    if (lastRule.IsCleanupRule())
                        package.ParentLayer.Rules.Remove(lastRule);
                }

                CheckPoint_Rule cpRule4GlobalLayer = new CheckPoint_Rule();
                cpRule4GlobalLayer.Name = "";
                cpRule4GlobalLayer.Layer = package.NameOfAccessLayer;
                cpRule4GlobalLayer.Source.Add(_cpObjects.GetObject(CheckPointObject.Any));
                cpRule4GlobalLayer.Destination.Add(_cpObjects.GetObject(CheckPointObject.Any));
                cpRule4GlobalLayer.Action = CheckPoint_Rule.ActionType.SubPolicy;
                cpRule4GlobalLayer.Track = CheckPoint_Rule.TrackTypes.None;
                cpRule4GlobalLayer.Time.Add(_cpObjects.GetObject(CheckPointObject.Any));
                cpRule4GlobalLayer.Service.Add(_cpObjects.GetObject(CheckPointObject.Any));
                cpRule4GlobalLayer.SubPolicyName = GlobalRulesSubpolicyName;

                package.ParentLayer.Rules.Add(cpRule4GlobalLayer);

                CheckPoint_Layer cpSubLayer4GlobalRules = new CheckPoint_Layer();
                cpSubLayer4GlobalRules.ApplicationsAndUrlFiltering = true;
                cpSubLayer4GlobalRules.Shared = true;
                cpSubLayer4GlobalRules.Name = cpRule4GlobalLayer.SubPolicyName;

                package.SubPolicies.Insert(0, cpSubLayer4GlobalRules); // insert at the begging becuase Global Rules should be created before all policy

                foreach (var globalPolicyRule in _ciscoGlobalAclCommands)
                {
                    // Append the global policy rules BELOW the existing sub-policies.                    
                    CheckPoint_Rule cpRule = Acl_To_CPRule(globalPolicyRule, cpSubLayer4GlobalRules.Name);
                    cpSubLayer4GlobalRules.Rules.Add(cpRule);
                }

                //add cleanup rule after all global rules

                // Do NOT create a cleanup rule if it already exists
                bool createCleanupRule = true;
                if (cpSubLayer4GlobalRules.Rules.Count > 0)
                {
                    var lastRule = cpSubLayer4GlobalRules.Rules[cpSubLayer4GlobalRules.Rules.Count - 1];
                    createCleanupRule = !lastRule.IsCleanupRule();
                }

                if (createCleanupRule)
                {
                    var cpCleanupRule = new CheckPoint_Rule();
                    cpCleanupRule.Name = CheckPoint_Rule.SubPolicyCleanupRuleName;
                    cpCleanupRule.Action = CheckPoint_Rule.ActionType.Drop;
                    cpCleanupRule.Layer = cpSubLayer4GlobalRules.Name;
                    cpSubLayer4GlobalRules.Rules.Add(cpCleanupRule);
                }

                // Fill in the shared layer with global policy rules INSIDE the existing sub-policies.
                foreach (CheckPoint_Layer subPolicy in package.SubPolicies)
                {
                    if (subPolicy.Name.Equals(cpSubLayer4GlobalRules.Name))
                    {
                        continue;
                    }

                    CheckPoint_Rule cpSubRule4GlobalLayer = cpRule4GlobalLayer.Clone();
                    cpSubRule4GlobalLayer.Name = "Global Layer";
                    cpSubRule4GlobalLayer.Layer = subPolicy.Name;
                    subPolicy.Rules.Add(cpSubRule4GlobalLayer);
                }


                //the last rule which is created by default by CheckPoint script importer. It is for report only.
                var cpRuleCleanUp = new CheckPoint_Rule();
                cpRuleCleanUp.Name = "Cleanup rule";
                package.ParentLayer.Rules.Add(cpRuleCleanUp);
            }
            else
            {
                foreach (Cisco_AccessList ciscoAcl in _ciscoGlobalAclCommands)
                {
                    // Fill in the global policy rules INSIDE the existing sub-policies.
                    foreach (CheckPoint_Rule cpParentRule in package.ParentLayer.Rules)
                    {
                        if (cpParentRule.Action == CheckPoint_Rule.ActionType.SubPolicy)
                        {
                            // Get into the relevant sub-policy
                            foreach (CheckPoint_Layer subPolicy in package.SubPolicies)
                            {
                                if (subPolicy.Name == cpParentRule.SubPolicyName)
                                {
                                    // This is done to avoid duplication of incident reporting over all matched sub-policy rules.
                                    ConversionIncidentType aclConversionIncident = ciscoAcl.ConversionIncidentType;
                                    ciscoAcl.ConversionIncidentType = ConversionIncidentType.None;

                                    var cpRule = Acl_To_CPRule(ciscoAcl, subPolicy.Name);

                                    cpRule.Layer = subPolicy.Name;

                                    if (!string.IsNullOrEmpty(subPolicy.Tag) && subPolicy.Tag == "InterfaceDisabled")
                                    {
                                        cpRule.Enabled = false;
                                    }

                                    // If the global ACL didn't have an incident previously, 
                                    // and the incident was just encountered during this convertion, retain the incident!!!
                                    if (ciscoAcl.ConversionIncidentType == ConversionIncidentType.None)
                                    {
                                        ciscoAcl.ConversionIncidentType = aclConversionIncident;
                                    }

                                    // Insert the global rules at the end of each sub-policy, BEFORE the cleanup rule.
                                    int rulesCount = subPolicy.Rules.Count;
                                    subPolicy.Rules.Insert(rulesCount - 1, cpRule);

                                    if (cpRule.ConversionIncidentType != ConversionIncidentType.None || ciscoAcl.ConversionIncidentType != ConversionIncidentType.None)
                                    {
                                        package.ConversionIncidentType = ConversionIncidentType.Informative;
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }

        private CheckPoint_Rule Acl_To_CPRule(Cisco_AccessList ciscoAcl, string layerName)
        {
            var cpRule = new CheckPoint_Rule();
            cpRule.Name = ciscoAcl.Description;
            cpRule.Enabled = !ciscoAcl.Inactive;
            if (layerName != null)
                cpRule.Layer = layerName;
            else
                cpRule.Layer = ciscoAcl.ACLName;

            cpRule.Comments = ciscoAcl.Remark;
            cpRule.ConversionComments = ciscoAcl.Id + ") " + ciscoAcl.Text;

            ApplyConversionIncidentOnCheckPointObject(cpRule, ciscoAcl);

            CheckPointObject cpObject;
            string srcObjectName;
            string destObjectName;

            if (ciscoAcl.IsTimeRangeSpecified)
            {
                List<string> cpTimeNamesList = null;
                _ciscoTimeNamesToCpTimeNamesDict.TryGetValue(ciscoAcl.TimeRangeName, out cpTimeNamesList);
                if (cpTimeNamesList != null)
                {
                    foreach (string cpTimeName in cpTimeNamesList)
                    {
                        cpObject = GetCheckPointObjectOrCreateDummy(cpTimeName,
                                                                CheckPointDummyObjectType.TimeGroup,
                                                                ciscoAcl,
                                                                "Not applying time-range objects to ACLs",
                                                                "Appropriate time object should be added manually.");
                        cpRule.Time.Add(cpObject);
                    }
                }
                else
                {
                    cpObject = GetCheckPointObjectOrCreateDummy("not_existing_object",
                                                                CheckPointDummyObjectType.TimeGroup,
                                                                ciscoAcl,
                                                                "Not applying time-range objects to ACLs",
                                                                "Appropriate time object should be added manually.");
                    cpRule.Time.Add(cpObject);
                }
            }

            switch (ciscoAcl.Source.Type)
            {
                case Cisco_AccessList.SourceDest.SourceDestType.Any:
                    cpRule.Source.Add(_cpObjects.GetObject(CheckPointObject.Any));
                    break;

                case Cisco_AccessList.SourceDest.SourceDestType.Any6:
                    cpObject = GetCheckPointObjectOrCreateDummy("not_existing_object",
                                                                CheckPointDummyObjectType.NetworkGroup,
                                                                ciscoAcl,
                                                                "Error creating a rule, IPv6 objects are not supported",
                                                                "Source details: Any6.");
                    cpRule.Source.Add(cpObject);
                    break;

                case Cisco_AccessList.SourceDest.SourceDestType.Host:
                    srcObjectName = (new CiscoNetwork(ciscoAcl.Id, ciscoAcl.Source.HostIp)).AutoGeneratedName();
                    cpObject = GetCheckPointObjectOrCreateDummy(srcObjectName,
                                                                CheckPointDummyObjectType.NetworkGroup,
                                                                ciscoAcl,
                                                                "Error creating a rule, missing information for source Cisco host",
                                                                "Host details: " + ciscoAcl.Source.HostIp + ".");
                    cpRule.Source.Add(cpObject);
                    break;

                case Cisco_AccessList.SourceDest.SourceDestType.SubnetAndMask:
                    srcObjectName = (new CiscoNetwork(ciscoAcl.Id, ciscoAcl.Source.Subnet, ciscoAcl.Source.Netmask)).AutoGeneratedName();
                    cpObject = GetCheckPointObjectOrCreateDummy(srcObjectName,
                                                                CheckPointDummyObjectType.NetworkGroup,
                                                                ciscoAcl,
                                                                "Error creating a rule, missing information for source Cisco network",
                                                                "Network details: " + ciscoAcl.Source.Subnet + " " + ciscoAcl.Source.Netmask + ".");
                    cpRule.Source.Add(cpObject);
                    break;

                case Cisco_AccessList.SourceDest.SourceDestType.ReferenceObject:
                    srcObjectName = ciscoAcl.Source.RefObjectName;
                    cpObject = GetCheckPointObjectOrCreateDummy(srcObjectName,
                                                                CheckPointDummyObjectType.NetworkGroup,
                                                                ciscoAcl,
                                                                "Error creating a rule, missing information for source Cisco object",
                                                                "Object details: " + srcObjectName + ".");
                    cpRule.Source.Add(cpObject);
                    break;
            }

            switch (ciscoAcl.Destination.Type)
            {
                case Cisco_AccessList.SourceDest.SourceDestType.Any:
                    cpRule.Destination.Add(_cpObjects.GetObject(CheckPointObject.Any));
                    break;

                case Cisco_AccessList.SourceDest.SourceDestType.Any6:
                    cpObject = GetCheckPointObjectOrCreateDummy("not_existing_object",
                                                                CheckPointDummyObjectType.NetworkGroup,
                                                                ciscoAcl,
                                                                "Error creating a rule, IPv6 objects are not supported",
                                                                "Destination details: Any6.");
                    cpRule.Destination.Add(cpObject);
                    break;

                case Cisco_AccessList.SourceDest.SourceDestType.Host:
                    destObjectName = (new CiscoNetwork(ciscoAcl.Id, ciscoAcl.Destination.HostIp)).AutoGeneratedName();
                    cpObject = GetCheckPointObjectOrCreateDummy(destObjectName,
                                                                CheckPointDummyObjectType.NetworkGroup,
                                                                ciscoAcl,
                                                                "Error creating a rule, missing information for destination Cisco host",
                                                                "Host details: " + ciscoAcl.Destination.HostIp + ".");
                    cpRule.Destination.Add(cpObject);
                    break;

                case Cisco_AccessList.SourceDest.SourceDestType.SubnetAndMask:
                    destObjectName = (new CiscoNetwork(ciscoAcl.Id, ciscoAcl.Destination.Subnet, ciscoAcl.Destination.Netmask)).AutoGeneratedName();
                    cpObject = GetCheckPointObjectOrCreateDummy(destObjectName,
                                                                CheckPointDummyObjectType.NetworkGroup,
                                                                ciscoAcl,
                                                                "Error creating a rule, missing information for destination Cisco network",
                                                                "Network details: " + ciscoAcl.Destination.Subnet + " " + ciscoAcl.Destination.Netmask + ".");
                    cpRule.Destination.Add(cpObject);
                    break;

                case Cisco_AccessList.SourceDest.SourceDestType.ReferenceObject:
                    destObjectName = ciscoAcl.Destination.RefObjectName;
                    cpObject = GetCheckPointObjectOrCreateDummy(destObjectName,
                                                                CheckPointDummyObjectType.NetworkGroup,
                                                                ciscoAcl,
                                                                "Error creating a rule, missing information for destination Cisco object",
                                                                "Object details: " + destObjectName + ".");
                    cpRule.Destination.Add(cpObject);
                    break;
            }

            switch (ciscoAcl.Action)
            {
                case Cisco_AccessList.ActionType.Permit:
                    cpRule.Action = CheckPoint_Rule.ActionType.Accept;
                    break;

                case Cisco_AccessList.ActionType.Deny:
                    cpRule.Action = CheckPoint_Rule.ActionType.Drop;
                    break;
            }

            if (ciscoAcl.Protocol == ProtocolType.NA)
            {
                cpObject = GetCheckPointObjectOrCreateDummy("not_existing_object",
                                                            CheckPointDummyObjectType.ServiceGroup,
                                                            ciscoAcl,
                                                            "Error creating a rule, unrecognized Cisco ACL protocol",
                                                            "Protocol details: " + ciscoAcl.ProtocolReference + ".");
                cpRule.Service.Add(cpObject);
                return cpRule;
            }

            if (ciscoAcl.Protocol != ProtocolType.ReferenceObject)   // a specific ACL protocol is used
            {
                // Destination service should be checked first
                if (ciscoAcl.DestinationProperties.Protocol != ProtocolType.NA && (ciscoAcl.DestinationProperties.WordsCount > 0 || ciscoAcl.DestinationProperties.TcpUdpPortOperator == TcpUdpPortOperatorType.All))
                {
                    if (ciscoAcl.DestinationProperties.TcpUdpPortOperator != TcpUdpPortOperatorType.ReferenceObject)   // specific protocol with a specific port
                    {
                        string serviceName = CheckPointServiceObjectsFactory.AutoGeneratedName(_cpObjects,
                                                                                               ciscoAcl.DestinationProperties.Protocol,
                                                                                               ciscoAcl.DestinationProperties.TcpUdpPortOperator,
                                                                                               ciscoAcl.DestinationProperties.TcpUdpPortValue,
                                                                                               ServiceDirection.Destination,
                                                                                               ciscoAcl.Id);
                        var dummyObjectType = (ciscoAcl.DestinationProperties.Protocol == ProtocolType.KnownOtherIpProtocol) ? CheckPointDummyObjectType.OtherService : CheckPointDummyObjectType.ServiceGroup;

                        cpObject = GetCheckPointObjectOrCreateDummy(serviceName,
                                                                    dummyObjectType,
                                                                    ciscoAcl,
                                                                    "Error creating a rule, missing information for Cisco destination service",
                                                                    "Service details: " + ciscoAcl.DestinationProperties.Protocol + " " + ciscoAcl.DestinationProperties.TcpUdpPortOperator + " " + ciscoAcl.DestinationProperties.TcpUdpPortValue + ".");
                        cpRule.Service.Add(cpObject);
                    }
                    else   // specific protocol with a service group of ports or icmp protocol with service group of icmp types
                    {
                        CiscoCommand ciscoPortReferenceCommand = _ciscoParser.GetCommandByCiscoId(ciscoAcl.DestinationProperties.TcpUdpPortValue);

                        if (ciscoPortReferenceCommand != null && ciscoPortReferenceCommand.Name() == "object-group")
                        {
                            var ciscoGroupReferenceObject = (Cisco_GroupObject)ciscoPortReferenceCommand;

                            if (ciscoGroupReferenceObject.GroupType == Cisco_GroupObject.Group_Type.Service)
                            {
                                Add_AclPorts_To_CPRule(ciscoAcl, ciscoGroupReferenceObject.ServiceProtocol, ciscoGroupReferenceObject, cpRule);
                            }
                            else if (ciscoGroupReferenceObject.GroupType == Cisco_GroupObject.Group_Type.Icmp)
                            {
                                Add_AclIcmpTypes_To_CPRule(ciscoAcl, ciscoGroupReferenceObject, cpRule);
                            }
                        }
                    }
                }

                // Now check the source service
                if (ciscoAcl.SourceProperties.Protocol != ProtocolType.NA && ciscoAcl.SourceProperties.WordsCount > 0)
                {
                    string serviceName = CheckPointServiceObjectsFactory.AutoGeneratedName(_cpObjects,
                                                                                           ciscoAcl.SourceProperties.Protocol,
                                                                                           ciscoAcl.SourceProperties.TcpUdpPortOperator,
                                                                                           ciscoAcl.SourceProperties.TcpUdpPortValue,
                                                                                           ServiceDirection.Source,
                                                                                           ciscoAcl.Id);

                    // Do we already have the destination services applied?
                    if (cpRule.Service.Count > 0)
                    {
                        cpRule.ConversionIncidentType = ConversionIncidentType.Informative;
                        ciscoAcl.ConversionIncidentType = ConversionIncidentType.Informative;

                        _conversionIncidents.Add(new ConversionIncident(ciscoAcl.Id,
                                                                        "Cannot convert ACL with both source service and destination service",
                                                                        "Ignoring source service: " + serviceName,
                                                                        ciscoAcl.ConversionIncidentType));
                    }
                    else   // no "regular" services - only source service
                    {
                        string errDescription;
                        if (ciscoAcl.SourceProperties.TcpUdpPortOperator == TcpUdpPortOperatorType.ReferenceObject)
                        {
                            errDescription = "Object details: " + ciscoAcl.SourceProperties.TcpUdpPortValue + ".";
                        }
                        else
                        {
                            errDescription = "Service details: " + ciscoAcl.SourceProperties.Protocol + " " + ciscoAcl.SourceProperties.TcpUdpPortOperator + " " + ciscoAcl.SourceProperties.TcpUdpPortValue + ".";
                        }

                        cpObject = GetCheckPointObjectOrCreateDummy("not_existing_object",
                                                                    CheckPointDummyObjectType.ServiceGroup,
                                                                    ciscoAcl,
                                                                    "Cannot convert ACL with only source service",
                                                                    errDescription);
                        cpRule.Service.Add(cpObject);
                    }
                }
            }
            else   // ProtocolType.ReferenceObject - ACL protocol is a referenced "object-group" or "object"
            {
                CiscoCommand ciscoProtocolReferenceCommand = _ciscoParser.GetCommandByCiscoId(ciscoAcl.ProtocolReference);

                if (ciscoProtocolReferenceCommand != null && ciscoProtocolReferenceCommand.Name() == "object-group")   // services group or protocols group
                {
                    var ciscoGroupReferenceObject = (Cisco_GroupObject)ciscoProtocolReferenceCommand;

                    if (ciscoGroupReferenceObject.GroupType == Cisco_GroupObject.Group_Type.Service)
                    {
                        Add_AclServices_To_CPRule(ciscoAcl, ciscoGroupReferenceObject, cpRule);
                    }
                    else if (ciscoGroupReferenceObject.GroupType == Cisco_GroupObject.Group_Type.Protocol)
                    {
                        Add_AclProtocols_To_CPRule(ciscoAcl, ciscoGroupReferenceObject, cpRule);
                    }
                }
                else if (ciscoProtocolReferenceCommand != null && ciscoProtocolReferenceCommand.Name() == "object")   // service object
                {
                    var ciscoReferenceObject = (Cisco_Object)ciscoProtocolReferenceCommand;

                    if (ciscoReferenceObject.ObjectType == Cisco_Object.ObjectTypes.IcmpService)   // using a predefined icmp object
                    {
                        string icmpName = CheckPointServiceObjectsFactory.AutoGeneratedName(_cpObjects,
                                                                                            ProtocolType.Icmp,
                                                                                            TcpUdpPortOperatorType.Eq,
                                                                                            ciscoReferenceObject.ServicePort,
                                                                                            ServiceDirection.Destination,
                                                                                            ciscoAcl.Id);
                        cpObject = GetCheckPointObjectOrCreateDummy(icmpName,
                                                                    CheckPointDummyObjectType.ServiceGroup,
                                                                    ciscoAcl,
                                                                    "Error creating a rule, missing information for Cisco destination service",
                                                                    "Service details: icmp " + ciscoReferenceObject.ServicePort + ".");
                        cpRule.Service.Add(cpObject);
                    }
                    else if (_cpObjects.HasObject(ciscoReferenceObject.CiscoId))
                    {
                        if (ciscoReferenceObject.IsDestination)
                        {
                            cpObject = GetCheckPointObjectOrCreateDummy(ciscoReferenceObject.CiscoId,
                                                                        CheckPointDummyObjectType.ServiceGroup,
                                                                        ciscoAcl,
                                                                        "Error creating a rule, missing information for Cisco service object",
                                                                        "Object details: " + ciscoReferenceObject.CiscoId + ".");
                            cpRule.Service.Add(cpObject);

                            // This may happen if both source and destination protocols are defined on the Cisco service!!!
                            if (ciscoReferenceObject.ConversionIncidentType != ConversionIncidentType.None)
                            {
                                ciscoAcl.ConversionIncidentType = ConversionIncidentType.Informative;
                            }
                        }
                        else
                        {
                            cpRule.ConversionIncidentType = ConversionIncidentType.Informative;
                            ciscoAcl.ConversionIncidentType = ConversionIncidentType.Informative;

                            _conversionIncidents.Add(new ConversionIncident(ciscoAcl.Id,
                                                                            "ACL protocol points to a source service",
                                                                            "Ignoring source service: " + ciscoReferenceObject.CiscoId + ".",
                                                                            ciscoAcl.ConversionIncidentType));
                        }
                    }
                    else
                    {
                        cpObject = GetCheckPointObjectOrCreateDummy("not_existing_object",
                                                                    CheckPointDummyObjectType.ServiceGroup,
                                                                    ciscoAcl,
                                                                    "Error creating a rule, missing information for Cisco service object",
                                                                    "Object details: " + ciscoReferenceObject.CiscoId + ".");
                        cpRule.Service.Add(cpObject);
                    }
                }
                else
                {
                    cpRule.ConversionIncidentType = ConversionIncidentType.ManualActionRequired;
                    ciscoAcl.ConversionIncidentType = ConversionIncidentType.ManualActionRequired;

                    _conversionIncidents.Add(new ConversionIncident(ciscoAcl.Id,
                                                                    "Error creating a rule, missing information for Cisco ACL protocol",
                                                                    "ACL Protocol details: " + ciscoAcl.ProtocolReference + ".",
                                                                    ciscoAcl.ConversionIncidentType));
                }
            }

            if (ciscoAcl.Protocol == ProtocolType.Icmp && cpRule.Service.Count == 0)
            {
                cpRule.Service.Add(_cpObjects.GetObject("icmp-proto"));
            }

            if (ciscoAcl.Protocol == ProtocolType.Tcp && cpRule.Service.Count == 0)
            {
                cpRule.Service.Add(_cpObjects.GetObject("unknown_protocol_tcp"));
            }

            if (ciscoAcl.Protocol == ProtocolType.Udp && cpRule.Service.Count == 0)
            {
                cpRule.Service.Add(_cpObjects.GetObject("unknown_protocol_udp"));
            }

            if (cpRule.Service.Count == 0)
            {
                // No service detected, or generic IP service protocol was skipped.
                // "any" service object will be used automatically...
            }

            return cpRule;
        }

        private void Add_AclServices_To_CPRule(Cisco_AccessList ciscoAcl, Cisco_GroupObject aclServices, CheckPoint_Rule cpRule)
        {
            // Avoid general "icmp-proto" service duplicates
            bool hasGeneralIcmpServiceMember = false;

            foreach (Cisco_ServiceObject ciscoService in aclServices.GetChildServices())
            {
                CheckPointObject cpObject;

                // Check for the case where we are referencing a service object by its name
                if (!string.IsNullOrEmpty(ciscoService.RefObjectName))
                {
                    var ciscoReferencedService = (Cisco_Object)_ciscoParser.GetCommandByCiscoId(ciscoService.RefObjectName);
                    if (ciscoReferencedService != null && _cpObjects.HasObject(ciscoReferencedService.CiscoId))
                    {
                        if (ciscoReferencedService.IsDestination)
                        {
                            cpObject = GetCheckPointObjectOrCreateDummy(ciscoReferencedService.CiscoId,
                                                                        CheckPointDummyObjectType.ServiceGroup,
                                                                        ciscoAcl,
                                                                        "Error creating a rule, missing information for Cisco service object",
                                                                        "Object details: " + ciscoReferencedService.CiscoId + ".");
                            cpRule.Service.Add(cpObject);

                            // This may happen, for example, if: 
                            // 1. both source and destination protocols are defined on the Cisco service
                            // 2. the Cisco service has a duplicate name
                            if (ciscoReferencedService.ConversionIncidentType != ConversionIncidentType.None)
                            {
                                ciscoAcl.ConversionIncidentType = ConversionIncidentType.Informative;
                            }
                        }
                        else
                        {
                            cpRule.ConversionIncidentType = ConversionIncidentType.Informative;
                            ciscoAcl.ConversionIncidentType = ConversionIncidentType.Informative;

                            _conversionIncidents.Add(new ConversionIncident(ciscoAcl.Id,
                                                                            "ACL protocol points to a service group with \"source-services\"",
                                                                            "Ignoring source service: " + ciscoReferencedService.CiscoId + ".",
                                                                            ciscoAcl.ConversionIncidentType));
                        }
                    }

                    continue;
                }

                if (ciscoService.IsDestination)
                {
                    if (ciscoService.Protocol == "tcp-udp")
                    {
                        string tcpServiceName = CheckPointServiceObjectsFactory.AutoGeneratedName(_cpObjects,
                                                                                                  "tcp",
                                                                                                  ciscoService.Operator,
                                                                                                  ciscoService.Port,
                                                                                                  ServiceDirection.Destination,
                                                                                                  ciscoService.Id);
                        cpObject = GetCheckPointObjectOrCreateDummy(tcpServiceName,
                                                                    CheckPointDummyObjectType.ServiceGroup,
                                                                    ciscoAcl,
                                                                    "Error creating a rule, missing information for Cisco destination service",
                                                                    "Service details: " + ciscoService.Protocol + " " + ciscoService.Operator + " " + ciscoService.Port + ".");
                        cpRule.Service.Add(cpObject);

                        string udpServiceName = CheckPointServiceObjectsFactory.AutoGeneratedName(_cpObjects,
                                                                                                  "udp",
                                                                                                  ciscoService.Operator,
                                                                                                  ciscoService.Port,
                                                                                                  ServiceDirection.Destination,
                                                                                                  ciscoService.Id);
                        cpObject = GetCheckPointObjectOrCreateDummy(udpServiceName,
                                                                    CheckPointDummyObjectType.ServiceGroup,
                                                                    ciscoAcl,
                                                                    "Error creating a rule, missing information for Cisco destination service",
                                                                    "Service details: " + ciscoService.Protocol + " " + ciscoService.Operator + " " + ciscoService.Port + ".");
                        cpRule.Service.Add(cpObject);
                    }
                    else if (ciscoService.Protocol == "ip")
                    {
                        cpRule.Service.Clear();   // "any" service object will be used automatically...

                        cpRule.ConversionIncidentType = ConversionIncidentType.Informative;
                        ciscoAcl.ConversionIncidentType = ConversionIncidentType.Informative;

                        _conversionIncidents.Add(new ConversionIncident(ciscoAcl.Id,
                                                                        "ACL protocol points to a service group with generic IP protocol",
                                                                        "Using \"any\" service object. Service group details: " + aclServices.CiscoId + ".",
                                                                        ciscoAcl.ConversionIncidentType));

                        return;
                    }
                    else   // regular icmp, tcp or udp, or other known ip protocol...
                    {
                        string serviceName = CheckPointServiceObjectsFactory.AutoGeneratedName(_cpObjects,
                                                                                               ciscoService.Protocol,
                                                                                               ciscoService.Operator,
                                                                                               ciscoService.Port,
                                                                                               ServiceDirection.Destination,
                                                                                               ciscoService.Id);
                        if (serviceName == "icmp-proto")
                        {
                            if (hasGeneralIcmpServiceMember)
                            {
                                continue;
                            }
                            hasGeneralIcmpServiceMember = true;
                        }

                        var dummyObjectType = (ciscoAcl.DestinationProperties.Protocol == ProtocolType.KnownOtherIpProtocol)
                            ? CheckPointDummyObjectType.OtherService
                            : CheckPointDummyObjectType.ServiceGroup;

                        cpObject = GetCheckPointObjectOrCreateDummy(serviceName,
                                                                    dummyObjectType,
                                                                    ciscoAcl,
                                                                    "Error creating a rule, missing information for Cisco destination service",
                                                                    "Service details: " + ciscoService.Protocol + " " + ciscoService.Operator + " " + ciscoService.Port + ".");
                        cpRule.Service.Add(cpObject);
                    }

                    // This may happen if both source and destination protocols are defined on the Cisco service!!!
                    if (ciscoService.ConversionIncidentType != ConversionIncidentType.None)
                    {
                        ciscoAcl.ConversionIncidentType = ConversionIncidentType.Informative;
                    }
                }
                else   // reference objects with source ports
                {
                    cpRule.ConversionIncidentType = ConversionIncidentType.Informative;
                    ciscoAcl.ConversionIncidentType = ConversionIncidentType.Informative;

                    _conversionIncidents.Add(new ConversionIncident(ciscoAcl.Id,
                                                                    "ACL protocol points to a service group with \"source-services\"",
                                                                    "Ignoring source service: " + ciscoService.Protocol + " " + ciscoService.Port + ", in group: " + ciscoAcl.ProtocolReference + ".",
                                                                    ciscoAcl.ConversionIncidentType));
                }
            }
        }

        private void Add_AclIcmpTypes_To_CPRule(Cisco_AccessList ciscoAcl, Cisco_GroupObject aclIcmpTypes, CheckPoint_Rule cpRule)
        {
            foreach (var icmpType in aclIcmpTypes.IcmpTypes)
            {
                string icmpName = CheckPointServiceObjectsFactory.AutoGeneratedName(_cpObjects,
                                                                                    ProtocolType.Icmp,
                                                                                    TcpUdpPortOperatorType.Eq,
                                                                                    icmpType,
                                                                                    ServiceDirection.Destination,
                                                                                    ciscoAcl.Id);
                var cpObject = GetCheckPointObjectOrCreateDummy(icmpName,
                                                                CheckPointDummyObjectType.ServiceGroup,
                                                                ciscoAcl,
                                                                "Error creating a rule, missing information for Cisco destination service",
                                                                "Service details: icmp " + icmpType + ".");
                cpRule.Service.Add(cpObject);
            }
        }

        private void Add_AclProtocols_To_CPRule(Cisco_AccessList ciscoAcl, Cisco_GroupObject aclProtocols, CheckPoint_Rule cpRule)
        {
            foreach (var proto in aclProtocols.Protocols)
            {
                string protocol = proto;
                var protocolType = CheckPointServiceObjectsFactory.ProtocolStringToProtocolType(ref protocol);
                if (protocolType == ProtocolType.NA)
                {
                    cpRule.ConversionIncidentType = ConversionIncidentType.ManualActionRequired;
                    ciscoAcl.ConversionIncidentType = ConversionIncidentType.ManualActionRequired;

                    _conversionIncidents.Add(new ConversionIncident(ciscoAcl.Id,
                                                                    "Error creating a rule, missing information for Cisco ACL protocol",
                                                                    "ACL Protocol details: " + protocol + ", in group: " + aclProtocols.CiscoId + ".",
                                                                    ciscoAcl.ConversionIncidentType));

                    continue;
                }

                string sPort = (protocolType == ProtocolType.KnownOtherIpProtocol) ? protocol : ciscoAcl.DestinationProperties.TcpUdpPortValue;

                if (protocolType == ProtocolType.KnownOtherIpProtocol || ciscoAcl.DestinationProperties.TcpUdpPortOperator != TcpUdpPortOperatorType.ReferenceObject)
                {
                    // specific protocol with a specific port
                    var cpObject = CheckPointServiceObjectsFactory.CreateServiceObj(_cpObjects,
                                                                                    protocolType,
                                                                                    ciscoAcl.DestinationProperties.TcpUdpPortOperator,
                                                                                    sPort,
                                                                                    ServiceDirection.Destination,
                                                                                    ciscoAcl.Id);
                    if (cpObject != null &&
                        (cpObject.GetType() == typeof(CheckPoint_TcpService) || cpObject.GetType() == typeof(CheckPoint_UdpService) || cpObject.GetType() == typeof(CheckPoint_OtherService)))
                    {
                        ApplyConversionIncidentOnCheckPointObject(cpObject, ciscoAcl);
                        AddCheckPointObject(cpObject);
                        cpRule.Service.Add(cpObject);
                    }
                }
                else
                {
                    // specific protocol with a service group of ports
                    CiscoCommand ciscoPortReferenceCommand = _ciscoParser.GetCommandByCiscoId(ciscoAcl.DestinationProperties.TcpUdpPortValue);

                    if (ciscoPortReferenceCommand != null && ciscoPortReferenceCommand.Name() == "object-group")
                    {
                        var ciscoGroupReferenceObject = (Cisco_GroupObject)ciscoPortReferenceCommand;

                        if (ciscoGroupReferenceObject.GroupType == Cisco_GroupObject.Group_Type.Service)
                        {
                            Add_AclPorts_To_CPRule(ciscoAcl, protocol, ciscoGroupReferenceObject, cpRule);
                        }
                    }
                }
            }
        }

        private void Add_AclPorts_To_CPRule(Cisco_AccessList ciscoAcl, string aclProtocol, Cisco_GroupObject aclPorts, CheckPoint_Rule cpRule)
        {
            foreach (Cisco_PortObject ciscoPort in aclPorts.GetChildPorts())
            {
                CheckPointObject cpObject;
                string serviceName;

                switch (aclProtocol)
                {
                    case "tcp-udp":
                        serviceName = CheckPointServiceObjectsFactory.AutoGeneratedName(_cpObjects,
                                                                                        ProtocolType.Tcp,
                                                                                        TcpUdpPortOperatorType.Eq,
                                                                                        ciscoPort.Port,
                                                                                        ServiceDirection.Destination,
                                                                                        ciscoPort.Id);
                        cpObject = GetCheckPointObjectOrCreateDummy(serviceName,
                                                                    CheckPointDummyObjectType.ServiceGroup,
                                                                    ciscoAcl,
                                                                    "Error creating a rule, missing information for Cisco service object",
                                                                    "Object details: " + aclPorts.CiscoId + ".");
                        cpRule.Service.Add(cpObject);

                        serviceName = CheckPointServiceObjectsFactory.AutoGeneratedName(_cpObjects,
                                                                                        ProtocolType.Udp,
                                                                                        TcpUdpPortOperatorType.Eq,
                                                                                        ciscoPort.Port,
                                                                                        ServiceDirection.Destination,
                                                                                        ciscoPort.Id);
                        cpObject = GetCheckPointObjectOrCreateDummy(serviceName,
                                                                    CheckPointDummyObjectType.ServiceGroup,
                                                                    ciscoAcl,
                                                                    "Error creating a rule, missing information for Cisco service object",
                                                                    "Object details: " + aclPorts.CiscoId + ".");
                        cpRule.Service.Add(cpObject);
                        break;

                    case "tcp":
                    case "udp":
                        serviceName = CheckPointServiceObjectsFactory.AutoGeneratedName(_cpObjects,
                                                                                        aclProtocol,
                                                                                        "eq",
                                                                                        ciscoPort.Port,
                                                                                        ServiceDirection.Destination,
                                                                                        ciscoPort.Id);
                        cpObject = GetCheckPointObjectOrCreateDummy(serviceName,
                                                                    CheckPointDummyObjectType.ServiceGroup,
                                                                    ciscoAcl,
                                                                    "Error creating a rule, missing information for Cisco service object",
                                                                    "Object details: " + aclPorts.CiscoId + ".");
                        cpRule.Service.Add(cpObject);
                        break;
                }
            }
        }

        private void Add_Layers_And_Rules_For_Other_Zones(CheckPoint_Package package)
        {
            var accessGroups = new List<string>();
            var accessGroupsExclude = new List<string>();
            var aclNames = new List<string>();

            foreach (CiscoCommand command in CiscoAccessGroupCommands)
            {
                var ciscoAccessGroup = (Cisco_AccessGroup)command;
                if (ciscoAccessGroup.Direction == Cisco_AccessGroup.DirectionType.Inbound)
                {
                    if (aclNames.Contains(ciscoAccessGroup.AccessListName))
                    {
                        continue;
                    }
                    aclNames.Add(ciscoAccessGroup.AccessListName);

                    accessGroups.Add(CiscoCommand.InterfacePrefix + ciscoAccessGroup.InterfaceName);
                }
                else
                {
                    // No Outbound nor Global...
                    accessGroupsExclude.Add(CiscoCommand.InterfacePrefix + ciscoAccessGroup.InterfaceName);
                }
            }

            var availableZones = new List<CheckPoint_Zone>();
            int availableZonesWithZeroSecurityLevel = 0;

            foreach (CheckPoint_Zone cpZone in _cpZones)
            {
                if (accessGroups.Contains(cpZone.Name) || accessGroupsExclude.Contains(cpZone.Name))
                {
                    continue;
                }

                // get Cisco interface object
                var ciscoInterface = (Cisco_Interface)_ciscoParser.GetCommandByCiscoId(cpZone.Name);
                if (ciscoInterface == null || !ciscoInterface.HasValidIpAddress() || ciscoInterface.ManagementOnly)
                {
                    continue;
                }

                availableZones.Add(cpZone);

                // If the _isInterInterfaceTrafficAllowed flag is on and there are at least two Cisco interfaces with zero security level, 
                // we should add sub-policies for the equivalent CP zones to allow traffic between them.
                if (ciscoInterface.SecurityLevel == 0)
                {
                    ++availableZonesWithZeroSecurityLevel;
                }
            }

            foreach (CheckPoint_Zone cpZone in availableZones)
            {
                // get Cisco interface object
                var ciscoInterface = (Cisco_Interface)_ciscoParser.GetCommandByCiscoId(cpZone.Name);

                bool addSubPolicy = (_isIntraInterfaceTrafficAllowed || (_isInterInterfaceTrafficAllowed && availableZonesWithZeroSecurityLevel >= 2))
                                        ? (ciscoInterface.SecurityLevel >= 0)
                                        : (ciscoInterface.SecurityLevel > 0);

                if (addSubPolicy)
                {
                    var cpLayer = new CheckPoint_Layer();
                    cpLayer.Name = cpZone.Name + "_sub_policy";

                    if (ciscoInterface.Shutdown)
                    {
                        cpLayer.Tag = "InterfaceDisabled";
                    }

                    if (_isIntraInterfaceTrafficAllowed)
                    {
                        var cpRule = new CheckPoint_Rule();
                        cpRule.ConversionComments = "Traffic allowed due to Cisco intra-interface configuration";
                        cpRule.Layer = cpLayer.Name;
                        cpRule.Action = CheckPoint_Rule.ActionType.Accept;
                        cpRule.Source.Add(cpZone);
                        cpRule.Destination.Add(cpZone);

                        if (ciscoInterface.Shutdown)
                        {
                            cpRule.Enabled = false;
                        }

                        cpLayer.Rules.Add(cpRule);
                    }

                    // add rules to this sub policy
                    foreach (CiscoCommand command in CiscoInterfaceCommands)
                    {
                        var otherCiscoInterface = (Cisco_Interface)command;

                        if (string.IsNullOrEmpty(otherCiscoInterface.CiscoId) ||
                            otherCiscoInterface.CiscoId == ciscoInterface.CiscoId ||
                            !otherCiscoInterface.HasValidIpAddress() ||
                            otherCiscoInterface.ManagementOnly)
                        {
                            continue;
                        }

                        bool addRule = _isInterInterfaceTrafficAllowed
                                           ? (ciscoInterface.SecurityLevel >= otherCiscoInterface.SecurityLevel)
                                           : (ciscoInterface.SecurityLevel > otherCiscoInterface.SecurityLevel);

                        if (addRule)
                        {
                            var cpRule = new CheckPoint_Rule();
                            cpRule.ConversionComments = otherCiscoInterface.CiscoId + " security level " + otherCiscoInterface.SecurityLevel;
                            cpRule.Layer = cpLayer.Name;
                            cpRule.Action = CheckPoint_Rule.ActionType.Accept;
                            cpRule.Destination.Add(_cpObjects.GetObject(otherCiscoInterface.CiscoId));

                            if (ciscoInterface.Shutdown || otherCiscoInterface.Shutdown)
                            {
                                cpRule.Enabled = false;
                            }

                            ApplyConversionIncidentOnCheckPointObject(cpRule, otherCiscoInterface);

                            cpLayer.Rules.Add(cpRule);
                        }
                    }

                    var cpCleanupRule = new CheckPoint_Rule();
                    cpCleanupRule.Name = CheckPoint_Rule.SubPolicyCleanupRuleName;
                    cpCleanupRule.Action = CheckPoint_Rule.ActionType.Drop;
                    cpCleanupRule.Layer = cpLayer.Name;

                    cpLayer.Rules.Add(cpCleanupRule);

                    package.SubPolicies.Add(cpLayer);
                    validatePackage(package);
                }
            }
        }

        private void DetectCheckPointFirewallRulesAffectedByInspectPolicy(CheckPoint_Package package)
        {
            var ciscoInspectedAclCommands = new List<Cisco_AccessList>();

            // Detect the affected ACLs
            foreach (var ciscoCommand in CiscoClassMapCommands)
            {
                var ciscoClassMapCommand = (Cisco_ClassMap)ciscoCommand;

                foreach (var matchedAclName in ciscoClassMapCommand.MatchedAclNames)
                {
                    foreach (CiscoCommand aclCommand in CiscoAclCommands)
                    {
                        var ciscoAcl = (Cisco_AccessList)aclCommand;
                        if (!ciscoAcl.IsRemark && ciscoAcl.ACLName == matchedAclName)
                        {
                            ciscoAcl.Tag = ciscoClassMapCommand.ClassMapName;
                            ciscoInspectedAclCommands.Add(ciscoAcl);
                        }
                    }
                }
            }

            // Go over the affected ACLs and match the fw rules by: source, destination and service fields
            foreach (var ciscoInspectedAcl in ciscoInspectedAclCommands)
            {
                var inspectedRule = Acl_To_CPRule(ciscoInspectedAcl, null);

                if ((inspectedRule.Source.Count == 1 && inspectedRule.Source[0].Name == CheckPointObject.Any) &&
                    (inspectedRule.Destination.Count == 1 && inspectedRule.Destination[0].Name == CheckPointObject.Any) &&
                    (inspectedRule.Service.Count == 1 && inspectedRule.Service[0].Name == CheckPointObject.Any))
                {
                    continue;   // cisco any/any/any??? skip!!!
                }

                bool foundMatchedRules = false;

                foreach (CheckPoint_Rule cpParentRule in package.ParentLayer.Rules)
                {
                    if (cpParentRule.Action != CheckPoint_Rule.ActionType.SubPolicy)
                    {
                        continue;
                    }

                    // Skip automatic rules for interfaces without access-group
                    if (cpParentRule.SubPolicyName.EndsWith("_sub_policy"))
                    {
                        continue;
                    }

                    // Get into the relevant sub-policy
                    foreach (CheckPoint_Layer subPolicy in package.SubPolicies)
                    {
                        if (subPolicy.Name != cpParentRule.SubPolicyName)
                        {
                            continue;
                        }

                        for (int ruleNumber = 0; ruleNumber < subPolicy.Rules.Count; ruleNumber++)
                        {
                            var cpRule = subPolicy.Rules[ruleNumber];

                            // Do not match on cleanup rule!!!
                            if (cpRule.IsCleanupRule())
                            {
                                continue;
                            }

                            // Do not match if rule's destination is 'any'
                            if (cpRule.Destination.Count == 1 && cpRule.Destination[0].Name == CheckPointObject.Any)
                            {
                                continue;
                            }

                            if (IsCheckPointFirewallRuleMatchedByInspectPolicy(cpRule, inspectedRule))
                            {
                                if (string.IsNullOrEmpty(cpRule.Tag))
                                {
                                    cpRule.Tag = ciscoInspectedAcl.Tag;   // Cisco Class-Map object name
                                }
                                else
                                {
                                    // There may be several class-maps (e.g: class1, class2, ...) matching the same fw rule...
                                    // BUT - do not tag on the SAME class-map (e.g: class1) multiple times!!!
                                    if (!cpRule.Tag.Contains(ciscoInspectedAcl.Tag))
                                    {
                                        cpRule.Tag += ",";
                                        cpRule.Tag += ciscoInspectedAcl.Tag;   // Cisco Class-Map object name
                                    }
                                }

                                foundMatchedRules = true;
                            }
                        }
                    }
                }

                if (foundMatchedRules)
                {
                    package.ConversionIncidentType = ConversionIncidentType.Informative;

                    _conversionIncidents.Add(new ConversionIncident(ciscoInspectedAcl.Id,
                                                                    "Check Point firewall rules traffic is affected by Cisco inspect policy",
                                                                    "Cisco class-map object: " + ciscoInspectedAcl.Tag + ". For rules details refer to the Converted Policy Report.",
                                                                    ConversionIncidentType.Informative));
                }
            }
        }

        private bool IsCheckPointFirewallRuleMatchedByInspectPolicy(CheckPoint_Rule fwRule, CheckPoint_Rule inspectedRule)
        {
            // Do not match on any/any/any rule!!!
            // There may be such rules due to usage of generic IP protocol as a service in ACL...
            if ((fwRule.Source.Count == 1 && fwRule.Source[0].Name == CheckPointObject.Any) &&
                (fwRule.Destination.Count == 1 && fwRule.Destination[0].Name == CheckPointObject.Any) &&
                (fwRule.Service.Count == 1 && fwRule.Service[0].Name == CheckPointObject.Any))
            {
                return false;
            }

            var fwRuleSourceRanges = (fwRule.Source.Count > 0) ? GetRanges(fwRule.Source[0]) : IPRanges.Any();
            var fwRuleDestRanges = (fwRule.Destination.Count > 0) ? GetRanges(fwRule.Destination[0]) : IPRanges.Any();
            var inspectedRuleSourceRanges = (inspectedRule.Source.Count > 0) ? GetRanges(inspectedRule.Source[0]) : IPRanges.Any();
            var inspectedRuleDestRanges = (inspectedRule.Destination.Count > 0) ? GetRanges(inspectedRule.Destination[0]) : IPRanges.Any();

            if (inspectedRuleSourceRanges.Overlaps(fwRuleSourceRanges) && inspectedRuleDestRanges.Overlaps(fwRuleDestRanges))
            {
                if ((fwRule.Service.Count == 1 && fwRule.Service[0].Name == CheckPointObject.Any) ||
                    (inspectedRule.Service.Count == 1 && inspectedRule.Service[0].Name == CheckPointObject.Any))
                {
                    return true;
                }

                // Inspected services should be a subset of fw services
                foreach (var inspectedService in inspectedRule.Service)
                {
                    bool matchService = fwRule.Service.Any(fwService => fwService.Name == inspectedService.Name);
                    if (!matchService)
                    {
                        return false;
                    }
                }

                return true;
            }

            return false;
        }

        private void Add_object_NAT()
        {
            foreach (Cisco_Object command in CiscoObjectCommands)
            {
                if (command.Children == null)
                {
                    continue;
                }

                foreach (CiscoCommand childCommand in command.Children)
                {
                    // This is for object-NAT only
                    if (childCommand.Name() == "nat")
                    {
                        var ciscoNat = (Cisco_Nat)childCommand;

                        var cpNatRule = new CheckPoint_NAT_Rule();
                        cpNatRule.Enabled = !ciscoNat.Inactive;
                        cpNatRule.Method = ciscoNat.IsStatic ? CheckPoint_NAT_Rule.NatMethod.Static : CheckPoint_NAT_Rule.NatMethod.Hide;
                        cpNatRule.Source = _cpObjects.GetObject(command.CiscoId);
                        cpNatRule.Comments = command.Id + ")" + (ciscoNat.IsStatic ? " Static " : " Dynamic ") + "object NAT for " + command.CiscoId;

                        cpNatRule.VendorCustomData = new CiscoNatCustomData();
                        ((CiscoNatCustomData)cpNatRule.VendorCustomData).Interface1 = ciscoNat.RealInterface;
                        ((CiscoNatCustomData)cpNatRule.VendorCustomData).Interface2 = ciscoNat.MappedInterface;
                        ((CiscoNatCustomData)cpNatRule.VendorCustomData).IsObjectNatRule = true;

                        ApplyConversionIncidentOnCheckPointObject(cpNatRule, ciscoNat);

                        string translatedSourceName;

                        string ciscoNetworkObjectName = ciscoNat.IsStatic ? ciscoNat.StaticNatIpAddressOrObjectName : ciscoNat.DynamicNatIpAddressOrObjectName;
                        var ciscoNetworkObject = _ciscoParser.GetCommandByCiscoId(ciscoNetworkObjectName);

                        if (ciscoNetworkObject != null)   // mapped_object_name
                        {
                            // Should be a host/network/range object only.
                            if (ciscoNetworkObject.GetType() == typeof(Cisco_Object))
                            {
                                var ciscoNetwork = (Cisco_Object)ciscoNetworkObject;

                                switch (ciscoNetwork.ObjectType)
                                {
                                    case Cisco_Object.ObjectTypes.Host:
                                        {
                                            var network = new CiscoNetwork(ciscoNat.Id, ciscoNetwork.HostAddress);

                                            var cpHostTranslated = new CheckPoint_Host();
                                            cpHostTranslated.Name = ciscoNetworkObjectName;
                                            cpHostTranslated.IpAddress = network.IpAddress;
                                            ApplyConversionIncidentOnCheckPointObject(cpHostTranslated, ciscoNat);
                                            AddCheckPointObject(cpHostTranslated);

                                            translatedSourceName = cpHostTranslated.Name;
                                        }
                                        break;

                                    case Cisco_Object.ObjectTypes.Network:
                                        {
                                            var network = new CiscoNetwork(ciscoNat.Id, ciscoNetwork.Network, ciscoNetwork.Netmask, ciscoNetwork.MaskPrefix);

                                            var cpNetworkTranslated = new CheckPoint_Network();
                                            cpNetworkTranslated.Name = ciscoNetworkObjectName;
                                            cpNetworkTranslated.Subnet = network.IpAddress;
                                            cpNetworkTranslated.Netmask = network.NetMask;
                                            ApplyConversionIncidentOnCheckPointObject(cpNetworkTranslated, ciscoNat);
                                            AddCheckPointObject(cpNetworkTranslated);

                                            translatedSourceName = cpNetworkTranslated.Name;
                                        }
                                        break;

                                    case Cisco_Object.ObjectTypes.Range:
                                        {
                                            var cpRangeTranslated = new CheckPoint_Range();
                                            cpRangeTranslated.Name = "r_" + ciscoNetwork.RangeFrom + "-" + ciscoNetwork.RangeTo;
                                            cpRangeTranslated.RangeFrom = ciscoNetwork.RangeFrom;
                                            cpRangeTranslated.RangeTo = ciscoNetwork.RangeTo;
                                            ApplyConversionIncidentOnCheckPointObject(cpRangeTranslated, ciscoNat);
                                            AddCheckPointObject(cpRangeTranslated);

                                            translatedSourceName = cpRangeTranslated.Name;
                                        }
                                        break;

                                    default:
                                        {
                                            var cpError = GetCheckPointObjectOrCreateDummy(ciscoNetwork.ObjectType.ToString(),
                                                                                           CheckPointDummyObjectType.Host,
                                                                                           ciscoNat,
                                                                                           "Error creating a NAT rule, missing information for Cisco translated source",
                                                                                           "Translated source details: " + ciscoNetworkObjectName + ".");
                                            translatedSourceName = cpError.Name;
                                        }
                                        break;
                                }
                            }
                            else
                            {
                                var cpError = GetCheckPointObjectOrCreateDummy("not_existing_object",
                                                                               CheckPointDummyObjectType.Host,
                                                                               ciscoNat,
                                                                               "Error creating a NAT rule, group object cannot be used as a translated source",
                                                                               "Group object details: " + ciscoNetworkObjectName + ".");
                                translatedSourceName = cpError.Name;
                            }
                        }
                        else
                        {
                            if (ciscoNat.IsHideBehindInterface)   // interface
                            {
                                // No need for translated source for NAT hidden behind an interface...
                                translatedSourceName = "";
                            }
                            else   // mapped_host_ip_address
                            {
                                // Can be a host IP address only.
                                var network = new CiscoNetwork(ciscoNat.Id, ciscoNat.IsStatic ? ciscoNat.StaticNatIpAddressOrObjectName : ciscoNat.DynamicNatIpAddressOrObjectName);

                                var cpHostTranslated = new CheckPoint_Host();
                                cpHostTranslated.Name = network.AutoGeneratedName();
                                cpHostTranslated.IpAddress = network.IpAddress;
                                ApplyConversionIncidentOnCheckPointObject(cpHostTranslated, ciscoNat);
                                AddCheckPointObject(cpHostTranslated);

                                translatedSourceName = cpHostTranslated.Name;
                            }
                        }

                        if (ciscoNat.IsHideBehindInterface)
                        {
                            cpNatRule.TranslatedSource = GetCheckPointObjectOrCreateDummy(CiscoCommand.InterfacePrefix + ciscoNat.MappedInterface + "_address",
                                                                                          CheckPointDummyObjectType.Host,
                                                                                          ciscoNat,
                                                                                          "Error creating a NAT rule, missing topology information for Cisco interface",
                                                                                          "Interface details: " + ciscoNat.MappedInterface + ".");
                        }
                        else   // hide behind an arbitrary ip/network
                        {
                            cpNatRule.TranslatedSource = _cpObjects.GetObject(translatedSourceName);
                        }

                        if (ciscoNat.MappedInterface == CiscoCommand.Any)
                        {
                            cpNatRule.Destination = _cpObjects.GetObject(CheckPointObject.Any);
                        }
                        else
                        {
                            var ciscoInterface = (Cisco_Interface)_ciscoParser.GetCommandByCiscoId(CiscoCommand.InterfacePrefix + ciscoNat.MappedInterface);
                            if (ciscoInterface != null && ciscoInterface.LeadsToInternet)
                            {
                                cpNatRule.Destination = _cpObjects.GetObject(CheckPointObject.Any);
                                ((CiscoNatCustomData)cpNatRule.VendorCustomData).IsNonNatSectionRule = true;
                            }
                            else
                            {
                                cpNatRule.Destination = GetCheckPointObjectOrCreateDummy(CiscoCommand.InterfacePrefix + ciscoNat.MappedInterface + "_subnets",
                                                                                         CheckPointDummyObjectType.NetworkGroup,
                                                                                         ciscoNat,
                                                                                         "Error creating a NAT rule, missing topology information for Cisco interface",
                                                                                         "Interface details: " + ciscoNat.MappedInterface + ".");
                            }
                        }

                        if (ciscoNat.IsStatic && !string.IsNullOrEmpty(ciscoNat.ServiceProtocol))
                        {
                            CheckPointObject cpService = CheckPointServiceObjectsFactory.CreateServiceObj(_cpObjects,
                                                                                                          (ciscoNat.ServiceProtocol == "tcp") ? ProtocolType.Tcp : ProtocolType.Udp,
                                                                                                          TcpUdpPortOperatorType.Eq,
                                                                                                          ciscoNat.ServiceId,
                                                                                                          ServiceDirection.Destination,
                                                                                                          ciscoNat.Id);
                            ApplyConversionIncidentOnCheckPointObject(cpService, ciscoNat);
                            AddCheckPointObject(cpService);

                            cpNatRule.Service = cpService;

                            if (ciscoNat.ServiceId != ciscoNat.TranslatedServiceId)
                            {
                                CheckPointObject cpTranslatedService = CheckPointServiceObjectsFactory.CreateServiceObj(_cpObjects,
                                                                                                                        (ciscoNat.ServiceProtocol == "tcp") ? ProtocolType.Tcp : ProtocolType.Udp,
                                                                                                                        TcpUdpPortOperatorType.Eq,
                                                                                                                        ciscoNat.TranslatedServiceId,
                                                                                                                        ServiceDirection.Destination,
                                                                                                                        ciscoNat.Id);
                                ApplyConversionIncidentOnCheckPointObject(cpTranslatedService, ciscoNat);
                                AddCheckPointObject(cpTranslatedService);

                                cpNatRule.TranslatedService = cpTranslatedService;
                            }
                        }

                        _cpPreorderedNatRules.Add(cpNatRule);

                        bool natRuleObjectHasConversionIncident = (cpNatRule.Source != null && cpNatRule.Source.ConversionIncidentType != ConversionIncidentType.None) ||
                                                                  (cpNatRule.TranslatedSource != null && cpNatRule.TranslatedSource.ConversionIncidentType != ConversionIncidentType.None) ||
                                                                  (cpNatRule.Destination != null && cpNatRule.Destination.ConversionIncidentType != ConversionIncidentType.None) ||
                                                                  (cpNatRule.TranslatedDestination != null && cpNatRule.TranslatedDestination.ConversionIncidentType != ConversionIncidentType.None) ||
                                                                  (cpNatRule.Service != null && cpNatRule.Service.ConversionIncidentType != ConversionIncidentType.None) ||
                                                                  (cpNatRule.TranslatedService != null && cpNatRule.TranslatedService.ConversionIncidentType != ConversionIncidentType.None);

                        if (cpNatRule.ConversionIncidentType != ConversionIncidentType.None ||
                            ciscoNat.ConversionIncidentType != ConversionIncidentType.None ||
                            natRuleObjectHasConversionIncident)
                        {
                            _hasNATConversionIncident = true;
                        }

                        // Mirrored NAT rule
                        if (ciscoNat.IsStatic && !ciscoNat.IsUnidirectional)
                        {
                            var cpNatMirrorRule = new CheckPoint_NAT_Rule();
                            cpNatMirrorRule.Enabled = cpNatRule.Enabled;
                            cpNatMirrorRule.Method = CheckPoint_NAT_Rule.NatMethod.Static;
                            cpNatMirrorRule.Source = cpNatRule.Destination;
                            cpNatMirrorRule.Destination = cpNatRule.TranslatedSource;
                            cpNatMirrorRule.Service = cpNatRule.TranslatedService ?? cpNatRule.Service;
                            cpNatMirrorRule.TranslatedDestination = _cpObjects.GetObject(command.CiscoId);
                            cpNatMirrorRule.TranslatedService = (cpNatRule.TranslatedService != null) ? cpNatRule.Service : cpNatRule.TranslatedService;
                            cpNatMirrorRule.Comments = "Mirror rule for object " + command.CiscoId;

                            cpNatMirrorRule.VendorCustomData = new CiscoNatCustomData();
                            ((CiscoNatCustomData)cpNatMirrorRule.VendorCustomData).Interface1 = ciscoNat.MappedInterface;
                            ((CiscoNatCustomData)cpNatMirrorRule.VendorCustomData).Interface2 = ciscoNat.RealInterface;
                            ((CiscoNatCustomData)cpNatMirrorRule.VendorCustomData).IsStaticMirrorRule = true;
                            ((CiscoNatCustomData)cpNatMirrorRule.VendorCustomData).IsObjectNatRule = true;
                            ((CiscoNatCustomData)cpNatMirrorRule.VendorCustomData).IsNonNatSectionRule = ((CiscoNatCustomData)cpNatRule.VendorCustomData).IsNonNatSectionRule;

                            _cpPreorderedNatRules.Add(cpNatMirrorRule);
                        }
                    }
                }
            }
        }

        private void Add_NAT_Rules()
        {
            // This is for manual-NAT, twice-NAT and auto-after-manual-twice-NAT
            List<CiscoCommand> natCommands = _ciscoParser.Filter("nat");

            foreach (CiscoCommand command in natCommands)
            {
                var ciscoNat = (Cisco_Nat)command;

                Add_IP_as_Host(ciscoNat.Id, ciscoNat.SourceId);
                if (!ciscoNat.IsHideBehindInterface)
                {
                    Add_IP_as_Host(ciscoNat.Id, ciscoNat.TranslatedSourceId);
                }
                Add_IP_as_Host(ciscoNat.Id, ciscoNat.DestinationId);
                Add_IP_as_Host(ciscoNat.Id, ciscoNat.TranslatedDestinationId);

                // Original NAT rule
                var cpNatRule = new CheckPoint_NAT_Rule();
                cpNatRule.Enabled = !ciscoNat.Inactive;
                cpNatRule.Method = ciscoNat.IsStatic ? CheckPoint_NAT_Rule.NatMethod.Static : CheckPoint_NAT_Rule.NatMethod.Hide;
                cpNatRule.Comments = ciscoNat.Id + ") " + ciscoNat.Text;

                cpNatRule.VendorCustomData = new CiscoNatCustomData();
                ((CiscoNatCustomData)cpNatRule.VendorCustomData).Interface1 = ciscoNat.RealInterface;
                ((CiscoNatCustomData)cpNatRule.VendorCustomData).Interface2 = ciscoNat.MappedInterface;
                ((CiscoNatCustomData)cpNatRule.VendorCustomData).IsAutoAfterSectionRule = ciscoNat.IsAutoAfter;

                if (ciscoNat.SourceId == ciscoNat.TranslatedSourceId && ciscoNat.DestinationId == ciscoNat.TranslatedDestinationId)
                {
                    ((CiscoNatCustomData)cpNatRule.VendorCustomData).IsNonNatRule = true;
                }

                ApplyConversionIncidentOnCheckPointObject(cpNatRule, ciscoNat);

                // Source
                if (ciscoNat.SourceId != CiscoCommand.Any)
                {
                    cpNatRule.Source = GetCheckPointObjectOrCreateDummy(ciscoNat.SourceId,
                                                                        CheckPointDummyObjectType.NetworkGroup,
                                                                        ciscoNat,
                                                                        "Error creating a NAT rule, missing information for Cisco source",
                                                                        "Source details: " + ciscoNat.SourceId + ".");

                    if (ciscoNat.RealInterface != CiscoCommand.Any)
                    {
                        var ciscoInterface = (Cisco_Interface)_ciscoParser.GetCommandByCiscoId(CiscoCommand.InterfacePrefix + ciscoNat.RealInterface);
                        if (ciscoInterface == null)
                        {
                            cpNatRule.ConversionIncidentType = ConversionIncidentType.ManualActionRequired;
                            ciscoNat.ConversionIncidentType = ConversionIncidentType.ManualActionRequired;

                            _conversionIncidents.Add(new ConversionIncident(ciscoNat.Id,
                                                                            "Error creating a NAT rule, missing information for Cisco interface",
                                                                            "Interface details: " + ciscoNat.RealInterface + ".",
                                                                            ciscoNat.ConversionIncidentType));
                        }
                        else if (ciscoInterface.LeadsToInternet)
                        {
                            ((CiscoNatCustomData)cpNatRule.VendorCustomData).IsNonNatSectionRule = true;
                        }
                    }
                }
                else   // Identity NAT ???
                {
                    if (ciscoNat.RealInterface == CiscoCommand.Any)
                    {
                        cpNatRule.Source = _cpObjects.GetObject(CheckPointObject.Any);
                    }
                    else
                    {
                        var ciscoInterface = (Cisco_Interface)_ciscoParser.GetCommandByCiscoId(CiscoCommand.InterfacePrefix + ciscoNat.RealInterface);
                        if (ciscoInterface != null && ciscoInterface.LeadsToInternet)
                        {
                            cpNatRule.Source = _cpObjects.GetObject(CheckPointObject.Any);
                            ((CiscoNatCustomData)cpNatRule.VendorCustomData).IsNonNatSectionRule = true;
                        }
                        else
                        {
                            cpNatRule.Source = GetCheckPointObjectOrCreateDummy(CiscoCommand.InterfacePrefix + ciscoNat.RealInterface + "_subnets",
                                                                                CheckPointDummyObjectType.NetworkGroup,
                                                                                ciscoNat,
                                                                                "Error creating a NAT rule, missing topology information for Cisco interface",
                                                                                "Interface details: " + ciscoNat.RealInterface + ".");
                        }
                    }
                }

                // Destination
                if (string.IsNullOrEmpty(ciscoNat.DestinationId))   // Manual NAT
                {
                    if (ciscoNat.MappedInterface == CiscoCommand.Any)
                    {
                        cpNatRule.Destination = _cpObjects.GetObject(CheckPointObject.Any);
                    }
                    else
                    {
                        var ciscoInterface = (Cisco_Interface)_ciscoParser.GetCommandByCiscoId(CiscoCommand.InterfacePrefix + ciscoNat.MappedInterface);
                        if (ciscoInterface != null && ciscoInterface.LeadsToInternet)
                        {
                            cpNatRule.Destination = _cpObjects.GetObject(CheckPointObject.Any);
                            ((CiscoNatCustomData)cpNatRule.VendorCustomData).IsNonNatSectionRule = true;
                        }
                        else
                        {
                            cpNatRule.Destination = GetCheckPointObjectOrCreateDummy(CiscoCommand.InterfacePrefix + ciscoNat.MappedInterface + "_subnets",
                                                                                     CheckPointDummyObjectType.NetworkGroup,
                                                                                     ciscoNat,
                                                                                     "Error creating a NAT rule, missing topology information for Cisco interface",
                                                                                     "Interface details: " + ciscoNat.MappedInterface + ".");
                        }
                    }
                }
                else   // Twice NAT
                {
                    if (ciscoNat.DestinationId != CiscoCommand.Any)
                    {
                        cpNatRule.Destination = GetCheckPointObjectOrCreateDummy(ciscoNat.DestinationId,
                                                                                 CheckPointDummyObjectType.NetworkGroup,
                                                                                 ciscoNat,
                                                                                 "Error creating a NAT rule, missing information for Cisco destination",
                                                                                 "Destination details: " + ciscoNat.DestinationId + ".");

                        if (ciscoNat.MappedInterface != CiscoCommand.Any)
                        {
                            var ciscoInterface = (Cisco_Interface)_ciscoParser.GetCommandByCiscoId(CiscoCommand.InterfacePrefix + ciscoNat.MappedInterface);
                            if (ciscoInterface == null)
                            {
                                cpNatRule.ConversionIncidentType = ConversionIncidentType.ManualActionRequired;
                                ciscoNat.ConversionIncidentType = ConversionIncidentType.ManualActionRequired;

                                _conversionIncidents.Add(new ConversionIncident(ciscoNat.Id,
                                                                                "Error creating a NAT rule, missing information for Cisco interface",
                                                                                "Interface details: " + ciscoNat.MappedInterface + ".",
                                                                                ciscoNat.ConversionIncidentType));
                            }
                            else if (ciscoInterface.LeadsToInternet)
                            {
                                ((CiscoNatCustomData)cpNatRule.VendorCustomData).IsNonNatSectionRule = true;
                            }
                        }
                    }
                    else
                    {
                        if (ciscoNat.MappedInterface == CiscoCommand.Any)
                        {
                            cpNatRule.Destination = _cpObjects.GetObject(CheckPointObject.Any);
                        }
                        else
                        {
                            var ciscoInterface = (Cisco_Interface)_ciscoParser.GetCommandByCiscoId(CiscoCommand.InterfacePrefix + ciscoNat.MappedInterface);
                            if (ciscoInterface != null && ciscoInterface.LeadsToInternet)
                            {
                                cpNatRule.Destination = _cpObjects.GetObject(CheckPointObject.Any);
                                ((CiscoNatCustomData)cpNatRule.VendorCustomData).IsNonNatSectionRule = true;
                            }
                            else
                            {
                                cpNatRule.Destination = GetCheckPointObjectOrCreateDummy(CiscoCommand.InterfacePrefix + ciscoNat.MappedInterface + "_subnets",
                                                                                         CheckPointDummyObjectType.NetworkGroup,
                                                                                         ciscoNat,
                                                                                         "Error creating a NAT rule, missing topology information for Cisco interface",
                                                                                         "Interface details: " + ciscoNat.MappedInterface + ".");
                            }
                        }
                    }
                }

                // Service
                if (!string.IsNullOrEmpty(ciscoNat.ServiceId))
                {
                    cpNatRule.Service = GetCheckPointObjectOrCreateDummy(ciscoNat.ServiceId,
                                                                         CheckPointDummyObjectType.ServiceGroup,
                                                                         ciscoNat,
                                                                         "Error creating a NAT rule, missing information for Cisco service",
                                                                         "Service details: " + ciscoNat.ServiceId + ".");
                }

                // Translated source
                if (ciscoNat.IsHideBehindInterface)
                {
                    cpNatRule.TranslatedSource = GetCheckPointObjectOrCreateDummy(CiscoCommand.InterfacePrefix + ciscoNat.MappedInterface + "_address",
                                                                                  CheckPointDummyObjectType.Host,
                                                                                  ciscoNat,
                                                                                  "Error creating a NAT rule, missing topology information for Cisco interface",
                                                                                  "Interface details: " + ciscoNat.MappedInterface + ".");
                }
                else if (ciscoNat.SourceId != ciscoNat.TranslatedSourceId && ciscoNat.TranslatedSourceId != CiscoCommand.Any)
                {
                    cpNatRule.TranslatedSource = GetCheckPointObjectOrCreateDummy(ciscoNat.TranslatedSourceId,
                                                                                  CheckPointDummyObjectType.Host,
                                                                                  ciscoNat,
                                                                                  "Error creating a NAT rule, missing information for Cisco translated source",
                                                                                  "Translated source details: " + ciscoNat.TranslatedSourceId + ".");
                }

                // Translated destination for Twice NAT only
                if (ciscoNat.DestinationId != ciscoNat.TranslatedDestinationId && ciscoNat.TranslatedDestinationId != CiscoCommand.Any)
                {
                    cpNatRule.TranslatedDestination = GetCheckPointObjectOrCreateDummy(ciscoNat.TranslatedDestinationId,
                                                                                       CheckPointDummyObjectType.Host,
                                                                                       ciscoNat,
                                                                                       "Error creating a NAT rule, missing information for Cisco translated destination",
                                                                                       "Translated destination details: " + ciscoNat.TranslatedDestinationId + ".");
                }

                // !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
                // If NAT source/destination/translated source/translated destination is a group object and there is only one member in the group,
                // then use object rather than group.
                // In case of NAT translated source/translated destination we should create an error host object because group cannot be used here!!!
                if (cpNatRule.Source != null && cpNatRule.Source.GetType() == typeof(CheckPoint_NetworkGroup))
                {
                    cpNatRule.Source = GetCheckPointObjectOrCreateDummyFromNetworkGroupWithSingleMember((CheckPoint_NetworkGroup)cpNatRule.Source, ciscoNat, false);
                }
                if (cpNatRule.Destination != null && cpNatRule.Destination.GetType() == typeof(CheckPoint_NetworkGroup))
                {
                    cpNatRule.Destination = GetCheckPointObjectOrCreateDummyFromNetworkGroupWithSingleMember((CheckPoint_NetworkGroup)cpNatRule.Destination, ciscoNat, false);
                }
                if (cpNatRule.TranslatedSource != null && cpNatRule.TranslatedSource.GetType() == typeof(CheckPoint_NetworkGroup))
                {
                    cpNatRule.TranslatedSource = GetCheckPointObjectOrCreateDummyFromNetworkGroupWithSingleMember((CheckPoint_NetworkGroup)cpNatRule.TranslatedSource, ciscoNat);
                }
                if (cpNatRule.TranslatedDestination != null && cpNatRule.TranslatedDestination.GetType() == typeof(CheckPoint_NetworkGroup))
                {
                    cpNatRule.TranslatedDestination = GetCheckPointObjectOrCreateDummyFromNetworkGroupWithSingleMember((CheckPoint_NetworkGroup)cpNatRule.TranslatedDestination, ciscoNat);
                }
                // !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

                // Translated Service
                if (ciscoNat.ServiceId != ciscoNat.TranslatedServiceId)
                {
                    cpNatRule.TranslatedService = GetCheckPointObjectOrCreateDummy(ciscoNat.TranslatedServiceId,
                                                                                   CheckPointDummyObjectType.ServiceGroup,
                                                                                   ciscoNat,
                                                                                   "Error creating a NAT rule, missing information for Cisco  translated service",
                                                                                   "Translated service details: " + ciscoNat.TranslatedServiceId + ".");
                }

                // Static NAT: if a source is a network or a network group and a translated source is a host, 
                // we should convert to dynamic NAT rule!!!
                if (cpNatRule.Method == CheckPoint_NAT_Rule.NatMethod.Static)
                {
                    if ((cpNatRule.Source.GetType() == typeof(CheckPoint_Network) || cpNatRule.Source.GetType() == typeof(CheckPoint_NetworkGroup)) &&
                        cpNatRule.TranslatedSource != null && cpNatRule.TranslatedSource.GetType() == typeof(CheckPoint_Host))
                    {
                        cpNatRule.Method = CheckPoint_NAT_Rule.NatMethod.Hide;
                        ciscoNat.IsStatic = false;
                    }
                }

                PostProcessNatRule64(cpNatRule);
                PostProcessNatRule46(cpNatRule);
                _cpPreorderedNatRules.Add(cpNatRule);

                bool natRuleObjectHasConversionIncident = (cpNatRule.Source != null && cpNatRule.Source.ConversionIncidentType != ConversionIncidentType.None) ||
                                                          (cpNatRule.TranslatedSource != null && cpNatRule.TranslatedSource.ConversionIncidentType != ConversionIncidentType.None) ||
                                                          (cpNatRule.Destination != null && cpNatRule.Destination.ConversionIncidentType != ConversionIncidentType.None) ||
                                                          (cpNatRule.TranslatedDestination != null && cpNatRule.TranslatedDestination.ConversionIncidentType != ConversionIncidentType.None) ||
                                                          (cpNatRule.Service != null && cpNatRule.Service.ConversionIncidentType != ConversionIncidentType.None) ||
                                                          (cpNatRule.TranslatedService != null && cpNatRule.TranslatedService.ConversionIncidentType != ConversionIncidentType.None);

                if (cpNatRule.ConversionIncidentType != ConversionIncidentType.None ||
                    ciscoNat.ConversionIncidentType != ConversionIncidentType.None ||
                    natRuleObjectHasConversionIncident)
                {
                    _hasNATConversionIncident = true;
                }

                // Mirrored NAT rule for Static NAT
                if (ciscoNat.IsStatic && !ciscoNat.IsUnidirectional)
                {
                    var cpNatMirrorRule = new CheckPoint_NAT_Rule();
                    cpNatMirrorRule.Enabled = cpNatRule.Enabled;
                    cpNatMirrorRule.Method = CheckPoint_NAT_Rule.NatMethod.Static;

                    if (((CiscoNatCustomData)cpNatRule.VendorCustomData).IsNonNatRule)
                    {
                        cpNatMirrorRule.Source = cpNatRule.Destination;
                        cpNatMirrorRule.Destination = cpNatRule.Source;
                    }
                    else
                    {
                        cpNatMirrorRule.Source = cpNatRule.TranslatedDestination ?? cpNatRule.Destination;
                        cpNatMirrorRule.Destination = cpNatRule.TranslatedSource ?? cpNatRule.Source;
                        if (!string.IsNullOrEmpty(ciscoNat.DestinationId))
                        {
                            cpNatMirrorRule.TranslatedSource = cpNatRule.Destination;
                        }
                        if (ciscoNat.SourceId != ciscoNat.TranslatedSourceId)
                        {
                            cpNatMirrorRule.TranslatedDestination = cpNatRule.Source;
                        }

                        // !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
                        // Network group cannot be used as NAT translated source/destination!!!
                        // Remediation:
                        // if only one member object in group, then use object rather than group,
                        // otherwise create an error host object.
                        if (cpNatMirrorRule.TranslatedSource != null && cpNatMirrorRule.TranslatedSource.GetType() == typeof(CheckPoint_NetworkGroup))
                        {
                            cpNatMirrorRule.TranslatedSource = GetCheckPointObjectOrCreateDummyFromNetworkGroupWithSingleMember((CheckPoint_NetworkGroup)cpNatMirrorRule.TranslatedSource, ciscoNat);
                        }
                        if (cpNatMirrorRule.TranslatedDestination != null && cpNatMirrorRule.TranslatedDestination.GetType() == typeof(CheckPoint_NetworkGroup))
                        {
                            cpNatMirrorRule.TranslatedDestination = GetCheckPointObjectOrCreateDummyFromNetworkGroupWithSingleMember((CheckPoint_NetworkGroup)cpNatMirrorRule.TranslatedDestination, ciscoNat);
                        }
                        // !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
                    }

                    cpNatMirrorRule.Service = cpNatRule.TranslatedService ?? cpNatRule.Service;
                    cpNatMirrorRule.TranslatedService = (cpNatRule.TranslatedService != null) ? cpNatRule.Service : cpNatRule.TranslatedService;
                    cpNatMirrorRule.Comments = string.Format("Mirror rule for {0}", ciscoNat.Id);

                    cpNatMirrorRule.VendorCustomData = new CiscoNatCustomData();
                    ((CiscoNatCustomData)cpNatMirrorRule.VendorCustomData).Interface1 = ciscoNat.MappedInterface;
                    ((CiscoNatCustomData)cpNatMirrorRule.VendorCustomData).Interface2 = ciscoNat.RealInterface;
                    ((CiscoNatCustomData)cpNatMirrorRule.VendorCustomData).IsStaticMirrorRule = true;
                    ((CiscoNatCustomData)cpNatMirrorRule.VendorCustomData).IsNonNatSectionRule = ((CiscoNatCustomData)cpNatRule.VendorCustomData).IsNonNatSectionRule;
                    ((CiscoNatCustomData)cpNatMirrorRule.VendorCustomData).IsAutoAfterSectionRule = ((CiscoNatCustomData)cpNatRule.VendorCustomData).IsAutoAfterSectionRule;

                    _cpPreorderedNatRules.Add(cpNatMirrorRule);

                    if (cpNatMirrorRule.ConversionIncidentType != ConversionIncidentType.None ||
                        ciscoNat.ConversionIncidentType != ConversionIncidentType.None)
                    {
                        _hasNATConversionIncident = true;
                    }
                }
            }
        }

        private void PostProcessNatRule64(CheckPoint_NAT_Rule natRule)
        {
            var isSourceHost = false;
            var isSourceNetwork = false;
            var isSourceIpv6 = false;
            if (natRule?.Source != null)
            {
                isSourceHost = natRule.Source is CheckPoint_Host;
                isSourceNetwork = natRule.Source is CheckPoint_Network;
                if (isSourceHost)
                {
                    var host = (CheckPoint_Host)natRule.Source;
                    isSourceIpv6 = NetworkUtils.IsValidIpv6(host.IpAddress);
                }
                if (isSourceNetwork)
                {
                    var network = (CheckPoint_Network)natRule.Source;
                    isSourceIpv6 = NetworkUtils.IsValidIpv6(network.Subnet);
                }
            }
            if (!isSourceIpv6)
            {
                // source is not Ipv6, no sense to continue
                return;
            }

            var isTranslatedSourceHost = false;
            var isTranslatedSourceNetwork = false;
            var isTranslatedSourceIpv4 = false;
            if (natRule?.TranslatedSource != null)
            {
                isTranslatedSourceHost = natRule.TranslatedSource is CheckPoint_Host;
                isTranslatedSourceNetwork = natRule.TranslatedSource is CheckPoint_Network;
                if (isTranslatedSourceHost)
                {
                    var host = (CheckPoint_Host)natRule.TranslatedSource;
                    isTranslatedSourceIpv4 = NetworkUtils.IsValidIpv4(host.IpAddress);
                }
                if (isTranslatedSourceNetwork)
                {
                    var network = (CheckPoint_Network)natRule.TranslatedSource;
                    isTranslatedSourceIpv4 = NetworkUtils.IsValidIpv4(network.Subnet);
                }
            }
            if (!isTranslatedSourceIpv4)
            {
                // translated source is not Ipv4, no sense to continue
                return;
            }

            // change NAT rule method
            natRule.Method = CheckPoint_NAT_Rule.NatMethod.Nat64;

            //  a address-range should be used instead of network of host for translated source
            IPRange ipRange;
            if (isTranslatedSourceNetwork)
            {
                var network = (CheckPoint_Network)natRule.TranslatedSource;
                ipRange = network.GetIPRanges().Ranges[0];
            }
            else // if translated source is a host
            {
                var host = (CheckPoint_Host)natRule.TranslatedSource;
                ipRange = host.GetIPRanges().Ranges[0];
            }
            var checkpointRange = new CheckPoint_Range();
            checkpointRange.RangeFrom = NetworkUtils.Number2Ip(ipRange.Minimum);
            checkpointRange.RangeTo = NetworkUtils.Number2Ip(ipRange.Maximum);
            checkpointRange.Name = "r_" + checkpointRange.RangeFrom + "-" + checkpointRange.RangeTo;
            if (_cpObjects.GetObject(checkpointRange.Name) == null)
            {
                AddCheckPointObject(checkpointRange);
            }
            natRule.TranslatedSource = checkpointRange;
        }

        private void PostProcessNatRule46(CheckPoint_NAT_Rule natRule)
        {
            var isSourceHost = false;
            var isSourceNetwork = false;
            var isSourceIpv4 = false;
            if (natRule?.Source != null)
            {
                isSourceHost = natRule.Source is CheckPoint_Host;
                isSourceNetwork = natRule.Source is CheckPoint_Network;
                if (isSourceHost)
                {
                    var host = (CheckPoint_Host)natRule.Source;
                    isSourceIpv4 = NetworkUtils.IsValidIpv4(host.IpAddress);
                }
                if (isSourceNetwork)
                {
                    var network = (CheckPoint_Network)natRule.Source;
                    isSourceIpv4 = NetworkUtils.IsValidIpv4(network.Subnet);
                }
            }
            if (!isSourceIpv4)
            {
                // source is not Ipv4, no sense to continue
                return;
            }

            var isTranslatedSourceHost = false;
            var isTranslatedSourceNetwork = false;
            var isTranslatedSourceIpv6 = false;
            if (natRule?.TranslatedSource != null)
            {
                isTranslatedSourceHost = natRule.TranslatedSource is CheckPoint_Host;
                isTranslatedSourceNetwork = natRule.TranslatedSource is CheckPoint_Network;
                if (isTranslatedSourceHost)
                {
                    var host = (CheckPoint_Host)natRule.TranslatedSource;
                    isTranslatedSourceIpv6 = NetworkUtils.IsValidIpv6(host.IpAddress);
                }
                if (isTranslatedSourceNetwork)
                {
                    var network = (CheckPoint_Network)natRule.TranslatedSource;
                    isTranslatedSourceIpv6 = NetworkUtils.IsValidIpv6(network.Subnet);
                }
            }
            if (!isTranslatedSourceIpv6)
            {
                // translated source is not Ipv6, no sense to continue
                return;
            }

            // change NAT rule method
            natRule.Method = CheckPoint_NAT_Rule.NatMethod.Nat46;
        }

        private void Add_IP_as_Host(int ciscoCommandId, string sIp)
        {
            // The order of this condition check is important!!!
            if (string.IsNullOrEmpty(sIp) || _cpObjects.HasObject(sIp) || !NetworkUtils.IsValidIp(sIp))
            {
                return;
            }

            var network = new CiscoNetwork(ciscoCommandId, sIp);

            var cpHost = new CheckPoint_Host();
            cpHost.Name = network.AutoGeneratedName();
            cpHost.IpAddress = network.IpAddress;
            cpHost.ConvertedCommandId = ciscoCommandId;
            AddCheckPointObject(cpHost);
        }

        private void CreateNATRulebase()
        {
            var section1 = new List<CheckPoint_NAT_Rule>();
            var section2Static = new List<CheckPoint_NAT_Rule>();
            var section2Dynamic = new List<CheckPoint_NAT_Rule>();
            var section3 = new List<CheckPoint_NAT_Rule>();
            var section5 = new List<CheckPoint_NAT_Rule>();
            var section6Static = new List<CheckPoint_NAT_Rule>();
            var section6Dynamic = new List<CheckPoint_NAT_Rule>();
            var section7 = new List<CheckPoint_NAT_Rule>();

            // Create the NAT sections
            foreach (var cpNatRule in _cpPreorderedNatRules)
            {
                var ciscoNatCustomData = ((CiscoNatCustomData)cpNatRule.VendorCustomData);

                // Create section #1:
                // Manual and twice NAT rules --> no Non-NAT and no auto-after and no object-NAT
                if (!ciscoNatCustomData.IsNonNatSectionRule && !ciscoNatCustomData.IsAutoAfterSectionRule && !ciscoNatCustomData.IsObjectNatRule)
                {
                    section1.Add(cpNatRule);
                }

                // Create section #2.1:
                // Object NAT rules - static --> no Non-NAT and no auto-after
                if (!ciscoNatCustomData.IsNonNatSectionRule && !ciscoNatCustomData.IsAutoAfterSectionRule && ciscoNatCustomData.IsObjectNatRule && cpNatRule.Method == CheckPoint_NAT_Rule.NatMethod.Static)
                {
                    section2Static.Add(cpNatRule);
                }

                // Create section #2.2:
                // Object NAT rules - dynamic --> no Non-NAT and no auto-after
                if (!ciscoNatCustomData.IsNonNatSectionRule && !ciscoNatCustomData.IsAutoAfterSectionRule && ciscoNatCustomData.IsObjectNatRule && cpNatRule.Method == CheckPoint_NAT_Rule.NatMethod.Hide)
                {
                    section2Dynamic.Add(cpNatRule);
                }

                // Create section #3:
                // Auto-After manual and twice NAT rules --> no Non-NAT and no object-NAT
                if (!ciscoNatCustomData.IsNonNatSectionRule && ciscoNatCustomData.IsAutoAfterSectionRule && !ciscoNatCustomData.IsObjectNatRule)
                {
                    section3.Add(cpNatRule);
                }

                // Create section #5:
                // Non-NAT manual and twice NAT rules --> no auto-after and no object-NAT
                if (ciscoNatCustomData.IsNonNatSectionRule && !ciscoNatCustomData.IsAutoAfterSectionRule && !ciscoNatCustomData.IsObjectNatRule)
                {
                    section5.Add(cpNatRule);
                }

                // Create section #6.1:
                // Non-NAT object NAT rules - static --> no auto-after
                if (ciscoNatCustomData.IsNonNatSectionRule && !ciscoNatCustomData.IsAutoAfterSectionRule && ciscoNatCustomData.IsObjectNatRule && cpNatRule.Method == CheckPoint_NAT_Rule.NatMethod.Static)
                {
                    section6Static.Add(cpNatRule);
                }

                // Create section #6.2:
                // Non-NAT object NAT rules - dynamic --> no auto-after
                if (ciscoNatCustomData.IsNonNatSectionRule && !ciscoNatCustomData.IsAutoAfterSectionRule && ciscoNatCustomData.IsObjectNatRule && cpNatRule.Method == CheckPoint_NAT_Rule.NatMethod.Hide)
                {
                    section6Dynamic.Add(cpNatRule);
                }

                // Create section #7:
                // Non-NAT auto-After manual and twice NAT rules --> no object-NAT
                if (ciscoNatCustomData.IsNonNatSectionRule && ciscoNatCustomData.IsAutoAfterSectionRule && !ciscoNatCustomData.IsObjectNatRule)
                {
                    section7.Add(cpNatRule);
                }
            }

            // Create the NAT Rulebase
            _cpNatRules.AddRange(section1);
            _cpNatRules.AddRange(section2Static);
            _cpNatRules.AddRange(section2Dynamic);
            _cpNatRules.AddRange(section3);

            // Do we need Non-NAT sections?
            if (section5.Any() || section6Static.Any() || section6Dynamic.Any() || section7.Any())
            {
                // Create section #4:
                // A single Non-NATs top rule
                var section4 = new CheckPoint_NAT_Rule();
                section4.Comments = "Auto-generated rule above interfaces that lead to the internet";
                section4.Method = CheckPoint_NAT_Rule.NatMethod.Static;
                section4.Source = _cpObjects.GetObject(AllInternalNetwotkGroupName);
                section4.Destination = _cpObjects.GetObject(AllInternalNetwotkGroupName);
                _cpNatRules.Add(section4);

                _cpNatRules.AddRange(section5);
                _cpNatRules.AddRange(section6Static);
                _cpNatRules.AddRange(section6Dynamic);
                _cpNatRules.AddRange(section7);
            }
        }

        private void MatchNATRulesIntoFirewallPolicy()
        {
            CheckPoint_Package cpPackage = _cpPackages[0];

            foreach (CheckPoint_NAT_Rule cpNatRule in _cpNatRules)
            {
                if (!cpNatRule.Enabled)
                {
                    continue;
                }

                var ciscoNatCustomData = ((CiscoNatCustomData)cpNatRule.VendorCustomData);

                // For example, NAT section #4 rule...
                if (cpNatRule.TranslatedSource == null && cpNatRule.TranslatedDestination == null)
                {
                    continue;
                }

                // Skip dynamic object-NAT rules
                if (ciscoNatCustomData.IsObjectNatRule && cpNatRule.Method == CheckPoint_NAT_Rule.NatMethod.Hide)
                {
                    continue;
                }

                // Skip dynamic manual-NAT rules
                if (!ciscoNatCustomData.IsObjectNatRule && cpNatRule.Method == CheckPoint_NAT_Rule.NatMethod.Hide && cpNatRule.TranslatedDestination == null)
                {
                    continue;
                }

                // Skip static NAT mirrored rules
                if (ciscoNatCustomData.IsStaticMirrorRule)
                {
                    continue;
                }

                // Skip Non-NAT rules (only twice-NAT: SourceId == TranslatedSourceId && DestinationId == TranslatedDestinationId)
                if (ciscoNatCustomData.IsNonNatRule)
                {
                    continue;
                }

                string natRuleInterface1 = (ciscoNatCustomData.Interface1 != CiscoCommand.Any) ? (CiscoCommand.InterfacePrefix + ciscoNatCustomData.Interface1) : ciscoNatCustomData.Interface1;
                string natRuleInterface2 = (ciscoNatCustomData.Interface2 != CiscoCommand.Any) ? (CiscoCommand.InterfacePrefix + ciscoNatCustomData.Interface2) : ciscoNatCustomData.Interface2;

                foreach (CheckPoint_Rule cpParentRule in cpPackage.ParentLayer.Rules)
                {
                    if (cpParentRule.Action != CheckPoint_Rule.ActionType.SubPolicy)
                    {
                        continue;
                    }

                    if (cpParentRule.Source[0] is CheckPoint_PredifinedObject && cpParentRule.Source[0].Name.Equals(CheckPointObject.Any))
                    {
                        if (cpParentRule.SubPolicyName != GlobalRulesSubpolicyName)
                        {
                            continue;
                        }
                    }

                    CheckPoint_Zone parentLayerRuleZone = new CheckPoint_Zone();
                    if (cpParentRule.SubPolicyName == GlobalRulesSubpolicyName)
                    {
                        parentLayerRuleZone.Name = "any";
                    }
                    else
                    {
                        parentLayerRuleZone = (CheckPoint_Zone)cpParentRule.Source[0];
                    }

                    // NAT rule interfaces should match on firewall rule interfaces (zones)
                    if (natRuleInterface1 != CiscoCommand.Any && natRuleInterface1 != parentLayerRuleZone.Name &&
                        natRuleInterface2 != CiscoCommand.Any && natRuleInterface2 != parentLayerRuleZone.Name)
                    {
                        continue;
                    }

                    // Get into the relevant sub-policy
                    foreach (CheckPoint_Layer subPolicy in cpPackage.SubPolicies)
                    {
                        if (subPolicy.Name != cpParentRule.SubPolicyName)
                        {
                            continue;
                        }

                        for (int ruleNumber = 0; ruleNumber < subPolicy.Rules.Count; ruleNumber++)
                        {
                            var cpRule = subPolicy.Rules[ruleNumber];

                            // Do not match on cleanup rule
                            if (cpRule.IsCleanupRule())
                            {
                                continue;
                            }

                            // Do not match if rule's destination is 'any'
                            if (cpRule.Destination.Count == 1)
                            {
                                string destinationName = cpRule.Destination[0].Name;
                                if (destinationName == CheckPointObject.Any)
                                {
                                    continue;
                                }

                                if (destinationName.StartsWith(CiscoCommand.InterfacePrefix))
                                {
                                    // get Cisco interface object
                                    var ciscoInterface = (Cisco_Interface)_ciscoParser.GetCommandByCiscoId(destinationName);
                                    if (ciscoInterface != null && (ciscoInterface.LeadsToInternet || ciscoInterface.SecurityLevel == 0))
                                    {
                                        continue;
                                    }
                                }
                            }

                            CheckPointObject newRuleDest = null;
                            bool serviceMatchedToo = false;

                            //dont't check added matched NAT rules
                            if (!cpRule.ConversionComments.StartsWith("Matched NAT rule") && IsFirewallRuleMatchedByNATRule(parentLayerRuleZone, cpNatRule, cpRule, out newRuleDest, out serviceMatchedToo))
                            {
                                string translatedSourceName = (cpNatRule.TranslatedSource != null) ? cpNatRule.TranslatedSource.Name : "original";
                                string translatedDestName = (cpNatRule.TranslatedDestination != null) ? cpNatRule.TranslatedDestination.Name : "original";
                                string translatedServiceName = (cpNatRule.TranslatedService != null) ?
                                                               cpNatRule.TranslatedService.Name : (cpNatRule.Service != null ? cpNatRule.Service.Name : "");

                                var newRule = new CheckPoint_Rule();

                                newRule.Enabled = cpRule.Enabled;
                                newRule.Source.AddRange(cpRule.Source);
                                newRule.Destination.Add(newRuleDest);
                                if (serviceMatchedToo)
                                {
                                    newRule.Service.Add(_cpObjects.GetObject(translatedServiceName));
                                }
                                else
                                {
                                    newRule.Service.AddRange(cpRule.Service);
                                }
                                newRule.Time.AddRange(cpRule.Time);
                                newRule.Action = cpRule.Action;
                                newRule.Layer = subPolicy.Name;
                                newRule.ConvertedCommandId = cpNatRule.ConvertedCommandId;
                                newRule.ConversionIncidentType = (cpRule.ConversionIncidentType != ConversionIncidentType.None) ? cpRule.ConversionIncidentType : cpNatRule.ConversionIncidentType;
                                if (serviceMatchedToo)
                                {
                                    translatedServiceName = (cpNatRule.TranslatedService != null) ? cpNatRule.TranslatedService.Name : "original";
                                    newRule.ConversionComments = "Matched NAT rule ((" + cpNatRule.ConvertedCommandId + ") translated source: " + translatedSourceName + ", translated dest: " + translatedDestName + ", translated service: " + translatedServiceName + ")";
                                }
                                else
                                {
                                    newRule.ConversionComments = "Matched NAT rule ((" + cpNatRule.ConvertedCommandId + ") translated source: " + translatedSourceName + ", translated dest: " + translatedDestName + ")";
                                }

                                //don't add duplicated rules
                                bool ruleIsAlreadyAdded = false;
                                foreach (var rule in subPolicy.Rules)
                                {
                                    if (newRule.CompareTo(rule))
                                    {
                                        ruleIsAlreadyAdded = true;
                                    }
                                }

                                // Add a new rule ABOVE the matched rule.
                                if (!ruleIsAlreadyAdded)
                                {
                                    subPolicy.Rules.Insert(ruleNumber, newRule);
                                }

                                if (newRule.ConversionIncidentType != ConversionIncidentType.None)
                                {
                                    cpPackage.ConversionIncidentType = ConversionIncidentType.Informative;
                                }

                                // If NAT rule's service is "any" (null), we need to keep matching for all relevant FW rules.
                                if (serviceMatchedToo)
                                {
                                    break;
                                }
                                else
                                {
                                    ++ruleNumber;   // this is because we are changing the collection during iteration!!!
                                }
                            }
                        }
                    }
                }
            }
        }

        /// <summary>
        /// !!! This method's logic follows the instructions from the "NAT rules matching FlowChart.vsd" document !!!
        /// </summary>
        private bool IsFirewallRuleMatchedByNATRule(CheckPoint_Zone parentLayerRuleZone, CheckPoint_NAT_Rule natRule, CheckPoint_Rule fwRule, out CheckPointObject newFwRuleDest, out bool serviceMatchedToo)
        {
            newFwRuleDest = null;
            serviceMatchedToo = false;

            var ciscoNatCustomData = ((CiscoNatCustomData)natRule.VendorCustomData);

            // If NAT rule interface is "any", it should match on EVERY firewall rule interface (zone)
            string natRuleInterface1 = (ciscoNatCustomData.Interface1 != CiscoCommand.Any) ? (CiscoCommand.InterfacePrefix + ciscoNatCustomData.Interface1) : parentLayerRuleZone.Name;
            string natRuleInterface2 = (ciscoNatCustomData.Interface2 != CiscoCommand.Any) ? (CiscoCommand.InterfacePrefix + ciscoNatCustomData.Interface2) : parentLayerRuleZone.Name;

            // Static NAT rule matching (no mirrors!!!)
            if (natRule.Method == CheckPoint_NAT_Rule.NatMethod.Static)
            {
                // Object-NAT rule matching
                if (ciscoNatCustomData.IsObjectNatRule)
                {
                    if (natRuleInterface2 == parentLayerRuleZone.Name)
                    {
                        var natSourceRanges = (natRule.Source != null) ? GetRanges(natRule.Source) : IPRanges.Any();
                        var fwRuleDestRanges = (fwRule.Destination.Count > 0) ? GetRanges(fwRule.Destination[0]) : IPRanges.Any();

                        if (fwRuleDestRanges.Overlaps(natSourceRanges))
                        {
                            newFwRuleDest = natRule.TranslatedSource ?? _cpObjects.GetObject(CheckPointObject.Any);
                        }
                    }
                }
                else   // Manual-NAT or Twice-NAT rule matching
                {
                    var natSourceRanges = (natRule.Source != null) ? GetRanges(natRule.Source) : IPRanges.Any();
                    var natDestRanges = (natRule.Destination != null) ? GetRanges(natRule.Destination) : IPRanges.Any();
                    var fwRuleSourceRanges = (fwRule.Source.Count > 0) ? GetRanges(fwRule.Source[0]) : IPRanges.Any();
                    var fwRuleDestRanges = (fwRule.Destination.Count > 0) ? GetRanges(fwRule.Destination[0]) : IPRanges.Any();

                    bool natSourceModified = (natRule.TranslatedSource != null);
                    bool natDestModified = (natRule.TranslatedDestination != null);   // Twice-NAT rule matching only!!!

                    if (natSourceModified && natDestModified)
                    {
                        var natTranslatedDestRanges = GetRanges(natRule.TranslatedDestination);

                        if (natRuleInterface2 == parentLayerRuleZone.Name)
                        {
                            if (fwRuleDestRanges.Overlaps(natSourceRanges) && fwRuleSourceRanges.Overlaps(natTranslatedDestRanges))
                            {
                                newFwRuleDest = natRule.TranslatedSource;
                            }
                        }

                        if (natRuleInterface1 == parentLayerRuleZone.Name)
                        {
                            var natTranslatedSourceRanges = GetRanges(natRule.TranslatedSource);

                            if (fwRuleDestRanges.Overlaps(natTranslatedDestRanges) && fwRuleSourceRanges.Overlaps(natTranslatedSourceRanges))
                            {
                                newFwRuleDest = natRule.Destination ?? _cpObjects.GetObject(CheckPointObject.Any);
                            }
                        }
                    }
                    else if (natSourceModified)
                    {
                        if (natRuleInterface2 == parentLayerRuleZone.Name)
                        {
                            if (fwRuleDestRanges.Overlaps(natSourceRanges) && fwRuleSourceRanges.Overlaps(natDestRanges))
                            {
                                newFwRuleDest = natRule.TranslatedSource;
                            }
                        }
                    }
                    else if (natDestModified)
                    {
                        if (natRuleInterface1 == parentLayerRuleZone.Name)
                        {
                            var natTranslatedDestRanges = GetRanges(natRule.TranslatedDestination);

                            if (fwRuleDestRanges.Overlaps(natTranslatedDestRanges) && fwRuleSourceRanges.Overlaps(natSourceRanges))
                            {
                                newFwRuleDest = natRule.Destination ?? _cpObjects.GetObject(CheckPointObject.Any);
                            }
                        }
                    }
                }
            }
            else   // Dynamic NAT rule matching (dynamic source and static dest)
            {
                bool natDestModified = (natRule.TranslatedDestination != null);   // Twice-NAT rule matching only!!!

                if (natDestModified)
                {
                    if (natRuleInterface1 == parentLayerRuleZone.Name)
                    {
                        var natSourceRanges = (natRule.Source != null) ? GetRanges(natRule.Source) : IPRanges.Any();
                        var natTranslatedDestRanges = GetRanges(natRule.TranslatedDestination);
                        var fwRuleSourceRanges = (fwRule.Source.Count > 0) ? GetRanges(fwRule.Source[0]) : IPRanges.Any();
                        var fwRuleDestRanges = (fwRule.Destination.Count > 0) ? GetRanges(fwRule.Destination[0]) : IPRanges.Any();

                        if (fwRuleDestRanges.Overlaps(natTranslatedDestRanges) && fwRuleSourceRanges.Overlaps(natSourceRanges))
                        {
                            newFwRuleDest = natRule.TranslatedDestination;
                        }
                    }
                }
            }

            // Match on service too...
            if (newFwRuleDest != null)
            {
                if (natRule.Service == null)
                {
                    // No NAT service at all
                    return true;
                }

                if (fwRule.Service.Count == 0)
                {
                    // TODO: ???
                }
                else if (fwRule.Service.Count == 1 && fwRule.Service[0].Name == CheckPointObject.Any)
                {
                    // There is only one service in FW rule and it is "any", no matter what NAT rule service is...
                    serviceMatchedToo = true;
                    return true;
                }
                else if (fwRule.Service.Any(fwService => natRule.Service.Name == fwService.Name ||
                         CheckPointServiceObjectsFactory.CheckServicesPortRangesOverlapping(natRule.Service, fwService)))
                {
                    // 1. service names match - NAT rule service appears in the list of FW rule's services
                    // 2. service port ranges match - NAT rule service should be a subset of FW rule's services
                    serviceMatchedToo = true;
                    return true;
                }
            }

            return false;
        }

        private IPRanges GetRanges(CheckPointObject cpObject)
        {
            if (cpObject == null || cpObject.Name == CheckPointObject.Any)
            {
                return new IPRanges(new IPRange(IPRange.Any));
            }

            if (cpObject.GetType().ToString().EndsWith("_NetworkGroup"))
            {
                return GetGroupRanges((CheckPoint_NetworkGroup)cpObject);
            }

            if (cpObject.GetType().ToString().EndsWith("_Zone"))
            {
                return GetZoneRanges((CheckPoint_Zone)cpObject);
            }

            if (cpObject.GetType().ToString().EndsWith("_Host"))
            {
                return ((CheckPoint_Host)cpObject).GetIPRanges();
            }

            if (cpObject.GetType().ToString().EndsWith("_Network"))
            {
                return ((CheckPoint_Network)cpObject).GetIPRanges();
            }

            if (cpObject.GetType().ToString().EndsWith("_Range"))
            {
                return ((CheckPoint_Range)cpObject).GetIPRanges();
            }

            return new IPRanges();
        }

        private IPRanges GetZoneRanges(CheckPoint_Zone cpZone)
        {
            // get Cisco interface object
            var ciscoInterface = (Cisco_Interface)_ciscoParser.GetCommandByCiscoId(cpZone.Name);
            if (ciscoInterface != null && (ciscoInterface.LeadsToInternet || ciscoInterface.SecurityLevel == 0))
            {
                return new IPRanges(new IPRange(IPRange.Any));
            }

            string ifcSubnetsName = cpZone.Name + "_subnets";
            var ifcGroupObject = _cpObjects.GetObject(ifcSubnetsName);
            if (ifcGroupObject != null)
            {
                if (ifcGroupObject.GetType().ToString().EndsWith("_NetworkGroup"))
                {
                    var ifcSubnets = (CheckPoint_NetworkGroup)ifcGroupObject;
                    return GetGroupRanges(ifcSubnets);
                }

                if (ifcGroupObject.GetType().ToString().EndsWith("_GroupWithExclusion"))
                {
                    var groupWithExclusion = (CheckPoint_GroupWithExclusion)ifcGroupObject;
                    var groupInclude = (CheckPoint_NetworkGroup)_cpObjects.GetObject(groupWithExclusion.Include);
                    var groupExcept = (CheckPoint_NetworkGroup)_cpObjects.GetObject(groupWithExclusion.Except);
                    return GetGroupWithExclusionRanges(groupInclude, groupExcept);
                }
            }

            return new IPRanges();
        }

        private void Add_Optimized_Package()
        {
            CheckPoint_Package regularPackage = _cpPackages[0];

            var optimizedPackage = new CheckPoint_Package();
            optimizedPackage.Name = _policyPackageOptimizedName;
            optimizedPackage.ParentLayer.Name = optimizedPackage.NameOfAccessLayer;
            optimizedPackage.ConversionIncidentType = regularPackage.ConversionIncidentType;

            var regular2OptimizedLayers = new Dictionary<string, string>();

            foreach (CheckPoint_Layer layer in regularPackage.SubPolicies)
            {
                string optimizedSubPolicyName = layer.Name + "_opt";

                CheckPoint_Layer optimizedLayer = RuleBaseOptimizer.Optimize(layer, optimizedSubPolicyName);
                foreach (CheckPoint_Rule subSubRule in optimizedLayer.Rules)
                {
                    if (subSubRule.SubPolicyName.Equals(GlobalRulesSubpolicyName))
                    {
                        //The Global sub-sub rule subpolicy name should also be renamed for consistency
                        subSubRule.SubPolicyName += "_opt";
                    }
                }
                if (!regular2OptimizedLayers.ContainsKey(layer.Name))
                {
                    regular2OptimizedLayers.Add(layer.Name, optimizedSubPolicyName);
                    optimizedPackage.SubPolicies.Add(optimizedLayer);
                    validatePackage(optimizedPackage);
                }
            }

            foreach (CheckPoint_Rule rule in regularPackage.ParentLayer.Rules)
            {
                CheckPoint_Rule newRule = rule.Clone();
                if (newRule.Action == CheckPoint_Rule.ActionType.SubPolicy)
                {
                    newRule.SubPolicyName = regular2OptimizedLayers[rule.SubPolicyName];
                }
                newRule.Layer = optimizedPackage.ParentLayer.Name;

                optimizedPackage.ParentLayer.Rules.Add(newRule);
            }

            AddCheckPointObject(optimizedPackage);
        }

        private string BuildInspectedRuleInfo(string ciscoClassMapName)
        {
            string inspectTooltip = "Rule traffic is affected by Cisco inspect policy. [class-map objects: " + ciscoClassMapName + "]";
            string htmlInspectedImageTag = string.Format(HtmlAlertImageTagFormat, inspectTooltip);
            return htmlInspectedImageTag;
        }

        private string BuildInspectedRuleLinkTag(string ciscoClassMapName)
        {
            foreach (var ciscoCommand in CiscoClassMapCommands)
            {
                var ciscoClassMapCommand = (Cisco_ClassMap)ciscoCommand;
                if (ciscoClassMapCommand.ClassMapName == ciscoClassMapName)
                {
                    return string.Format("<a href=\"./{0}#line_{1}\" target=\"_blank\">{2}</a>", Path.GetFileName(VendorHtmlFile), ciscoClassMapCommand.Id, ciscoClassMapName);
                }
            }

            return ciscoClassMapName;
        }

        #endregion

        #region Public Methods

        public override void Initialize(VendorParser vendorParser, string vendorFilePath, string toolVersion, string targetFolder, string domainName)
        {
            _ciscoParser = (CiscoParser)vendorParser;
            if (_ciscoParser == null)
            {
                throw new InvalidDataException("Unexpected!!!");
            }

            base.Initialize(vendorParser, vendorFilePath, toolVersion, targetFolder, domainName);
        }

        public override void Convert(bool convertNat)
        {
            RaiseConversionProgress(20, "Converting obects ...");
            _cpObjects.Initialize();   // must be first!!!

            foreach (var cpObject in _cpObjects.GetPredefinedObjects())
            {
                _duplicateNamesLookup.Add(cpObject.Name, new DuplicateNameInfo(true));
            }

            PopulateCiscoNetworkObjects();
            CheckCiscoInterfacesTraffic();
            CheckCiscoInterfacesAntiSpoofing();
            Add_Networks();
            Add_Objects();
            Add_NetworkGroups();
            Add_InterfacesAndRoutes();
            Add_Zones();
            Add_or_Modify_InterfaceNetworkGroups();
            Add_ServicesAndServiceGroups();
            Add_TimeRanges();
            RaiseConversionProgress(30, "Converting rules ...");
            Add_Package();

            if (convertNat)
            {
                RaiseConversionProgress(40, "Converting NAT rules ...");
                Add_object_NAT();
                Add_NAT_Rules();
                RaiseConversionProgress(50, "Creating NAT rulebase ...");
                CreateNATRulebase();
                RaiseConversionProgress(60, "Creating Firewall rulebase ...");
                MatchNATRulesIntoFirewallPolicy();
            }

            // This should be done here, after all objects are converted!!!
            EnforceObjectNameValidity();

            RaiseConversionProgress(70, "Optimizing Firewall rulebase ...");
            Add_Optimized_Package();
            RaiseConversionProgress(80, "Generating CLI scripts ...");
            CreateObjectsScript();
            CreatePackagesScript();
            CreateObjectsHtml();

            // This data container is important, and is used during rulebases html reports generation for incidents lookup!!!
            var incidentsGroupedByLineNumber = _conversionIncidents.GroupBy(error => error.LineNumber);
            _conversionIncidentsByLineNumber = incidentsGroupedByLineNumber.ToDictionary(error => error.Key, error => error.Distinct().ToList());

            // Resolve the conversion categories/lines count to report to the user.
            ConversionIncidentCategoriesCount = _conversionIncidents.GroupBy(error => error.Title).Count();
            ConversionIncidentsCommandsCount = _conversionIncidents.GroupBy(error => error.LineNumber).Count();

            CreateSmartConnector();
        }

        public override int RulesInConvertedPackage()
        {
            return _cpPackages[0].TotalRules();
        }

        public override int RulesInConvertedOptimizedPackage()
        {
            return _cpPackages[1].TotalRules();
        }

        public override int RulesInNatLayer()
        {
            return _cpNatRules.Count;
        }

        public override void ExportConfigurationAsHtml()
        {
            using (var file = new StreamWriter(VendorHtmlFile))
            {
                file.WriteLine("<html>");
                file.WriteLine("<head>");
                file.WriteLine("<style>");
                file.WriteLine("  body { font-family: Arial; }");
                file.WriteLine("  .report_table { border-collapse: separate;border-spacing: 0px; font-family: Lucida Console;}");
                file.WriteLine("  td {padding: 5px; vertical-align: top}");
                file.WriteLine("  .line_number {background: lightgray;}");
                file.WriteLine("  .unhandeled {color: Fuchsia;}");
                file.WriteLine("  .notimportant {color: Gray;}");
                file.WriteLine("  .converterr {color: Red;}");
                file.WriteLine("  .convertinfo {color: Blue;}");
                file.WriteLine("  .err_title {color: Red;}");
                file.WriteLine("  .info_title {color: Blue;}");
                file.WriteLine("</style>");
                file.WriteLine("</head>");

                file.WriteLine("<body>");
                file.WriteLine("<h2>Cisco config file</h2>");

                file.WriteLine("<table style='margin-bottom: 20px; background: rgb(250,250,250);'>");
                file.WriteLine("   <tr><td style='font-size: 14px; text-decoration: underline;'>Colors Legend</td></tr>");
                file.WriteLine("   <tr><td style='font-size: 12px; color: Black;'>Parsed commands</td></tr>");
                file.WriteLine("   <tr><td style='font-size: 12px; color: Gray;'>Skipped commands</td></tr>");
                file.WriteLine("   <tr><td style='font-size: 12px; color: Fuchsia;'>Unknown commands</td></tr>");
                file.WriteLine("   <tr><td style='font-size: 12px; color: Red;'>Commands with conversion error</td></tr>");
                file.WriteLine("   <tr><td style='font-size: 12px; color: Blue;'>Commands with conversion notification</td></tr>");
                file.WriteLine("</table>");

                file.WriteLine("<div style='margin-bottom: 20px; font-size: 14px; color: Blue;'>");
                file.WriteLine("   <span style='vertical-align: middle; font-size: 14px;'>" + HtmlAlertImageTag);
                file.WriteLine("      <a> Valid Check Point object name consists of the following characters only - \"A-Za-z0-9_.-\". Any invalid character will be replaced with a \"_\" character.</a>");
                file.WriteLine("   </span>");
                file.WriteLine("</div>");

                if (_conversionIncidents.Count > 0)
                {
                    file.WriteLine("<div style='margin-bottom: 20px;'>");
                    file.WriteLine("   <span style='vertical-align: middle; font-size: 14px;'>" + HtmlAlertImageTag);
                    file.WriteLine("      <a href='#ConversionIncidents'>Found " + ConversionIncidentCategoriesCount + " conversion issues in " + ConversionIncidentsCommandsCount + " configuration lines</a>");
                    file.WriteLine("   </span>");
                    file.WriteLine("</div>");
                }

                file.WriteLine("<table class=\"report_table\">");

                foreach (CiscoCommand command in CiscoAllCommands)
                {
                    string lineStyle = "";
                    string indentation = "";

                    if (!command.KnownCommand) lineStyle = " class=\"unhandeled\" ";
                    if (command.NotAnInterestingCommand) lineStyle = " class=\"notimportant\" ";
                    if (command.ConversionIncidentType == ConversionIncidentType.ManualActionRequired) lineStyle = " class=\"converterr\" ";
                    if (command.ConversionIncidentType == ConversionIncidentType.Informative) lineStyle = " class=\"convertinfo\" ";

                    for (int i = 0; i < command.IndentationLevel; i++)
                    {
                        indentation += "&nbsp;&nbsp;";
                    }

                    string incidentFlag = "";
                    if (command.ConversionIncidentType != ConversionIncidentType.None)
                    {
                        ConversionIncidentType highestIncidentType;
                        incidentFlag = BuildConversionIncidentInfo(command.Id, out highestIncidentType);
                    }

                    file.WriteLine("<tr>");
                    file.WriteLine("  <td id=\"line_" + command.Id + "\" class=\"line_number\" style=\"text-align: right;\">" + incidentFlag + command.Id + "</td>" + "<td " + lineStyle + " >" + indentation + command.Text + "</td>");
                    file.WriteLine("</tr>");
                }
                file.WriteLine("</table>");

                if (_conversionIncidents.Count > 0)
                {
                    file.WriteLine("<hr/>");
                    file.WriteLine("<h2 id=\"ConversionIncidents\">Conversion Issues</h2>");

                    bool first = true;
                    ConversionIncident prevErr = null;

                    foreach (ConversionIncident err in _conversionIncidents.OrderByDescending(item => item.IncidentType).ThenBy(item => item.Title).ThenBy(item => item.LineNumber).ToList())
                    {
                        if (first)
                        {
                            if (err.IncidentType == ConversionIncidentType.ManualActionRequired)
                            {
                                file.WriteLine("<h4 class=\"err_title\">" + err.Title + "</h4>");
                            }
                            else
                            {
                                file.WriteLine("<h4 class=\"info_title\">" + err.Title + "</h4>");
                            }
                            file.WriteLine("<table class=\"report_table\">");
                        }

                        if (!first && prevErr.Title != err.Title)
                        {
                            file.WriteLine("</table>");

                            if (err.IncidentType == ConversionIncidentType.ManualActionRequired)
                            {
                                file.WriteLine("<h4 class=\"err_title\">" + err.Title + "</h4>");
                            }
                            else
                            {
                                file.WriteLine("<h4 class=\"info_title\">" + err.Title + "</h4>");
                            }
                            file.WriteLine("<table class=\"report_table\">");
                        }

                        // Do not display the same description for the same line...
                        if (prevErr == null || prevErr.LineNumber != err.LineNumber || prevErr.Description != err.Description)
                        {
                            file.WriteLine("  <tr>");
                            file.WriteLine("    <td class=\"line_number\" style=\"text-align: right;\"> <a href=\"#line_" + err.LineNumber + "\">" + err.LineNumber + "</a></td>");
                            file.WriteLine("    <td>" + err.Description + "</td>");
                            file.WriteLine("  </tr>");
                        }

                        first = false;
                        prevErr = err;
                    }
                }

                file.WriteLine("</body>");
                file.WriteLine("</html>");
            }
        }

        public override void ExportPolicyPackagesAsHtml()
        {
            const string ruleIdPrefix = "rule_";

            foreach (CheckPoint_Package package in _cpPackages)
            {
                string filename = _targetFolder + "\\" + package.Name + ".html";

                using (var file = new StreamWriter(filename, false))
                {
                    var rulesWithConversionErrors = new Dictionary<string, CheckPoint_Rule>();
                    var rulesWithConversionInfos = new Dictionary<string, CheckPoint_Rule>();
                    var rulesWithInspection = new Dictionary<string, List<CheckPoint_Rule>>();

                    GeneratePackageHtmlReportHeaders(file, package.Name, package.ConversionIncidentType != ConversionIncidentType.None);

                    // Generate the report body
                    file.WriteLine("<table>");
                    file.WriteLine("   <tr>");
                    file.WriteLine("      <th colspan='3'>No.</th> <th>Name</th> <th>Source</th> <th>Destination</th> <th>Service</th> <th>Action</th> <th>Time</th> <th>Track</th> <th>Comments</th> <th>Conversion Comments</th>");
                    file.WriteLine("   </tr>");

                    int ruleNumber = 1;

                    foreach (CheckPoint_Rule rule in package.ParentLayer.Rules)
                    {
                        bool isSubPolicy = false;
                        string action = "";
                        string actionStyle = "";
                        var dummy = ConversionIncidentType.None;

                        switch (rule.Action)
                        {
                            case CheckPoint_Rule.ActionType.Accept:
                            case CheckPoint_Rule.ActionType.Drop:
                                action = rule.Action.ToString();
                                actionStyle = rule.Action.ToString().ToLower();
                                break;

                            case CheckPoint_Rule.ActionType.SubPolicy:
                                isSubPolicy = true;
                                action = "Sub-policy: " + rule.SubPolicyName;
                                actionStyle = "";
                                break;
                        }

                        string curParentRuleId = string.Format("{0}{1}", ruleIdPrefix, ruleNumber);

                        if (rule.Enabled)
                        {
                            file.WriteLine("  <tr class='parent_rule' id=\"" + curParentRuleId + "\">");
                            if (isSubPolicy)
                            {
                                file.WriteLine("      <td class='rule_number' colspan='3' onclick='toggleSubRules(this)'>" +
                                    string.Format(HtmlSubPolicyArrowImageTagFormat, curParentRuleId + "_img", HtmlDownArrowImageSourceData) + ruleNumber + "</td>");
                            }
                            else
                            {
                                file.WriteLine("      <td class='rule_number' colspan='3' style='padding-left:22px;'>" + ruleNumber + "</td>");
                            }
                        }
                        else
                        {
                            file.WriteLine("  <tr class='parent_rule_disabled' id=\"" + curParentRuleId + "\">");
                            if (isSubPolicy)
                            {
                                file.WriteLine("      <td class='rule_number' colspan='3' onclick='toggleSubRules(this)'>" +
                                    string.Format(HtmlSubPolicyArrowImageTagFormat, curParentRuleId + "_img", HtmlDownArrowImageSourceData) + ruleNumber + HtmlDisabledImageTag + "</td>");
                            }
                            else
                            {
                                file.WriteLine("      <td class='rule_number' colspan='3' style='padding-left:22px;'>" + ruleNumber + HtmlDisabledImageTag + "</td>");
                            }
                        }
                        file.WriteLine("      <td>" + rule.Name + "</td>");
                        file.WriteLine("      <td>" + RuleItemsList2Html(rule.Source, rule.SourceNegated, CheckPointObject.Any, ref dummy) + "</td>");
                        file.WriteLine("      <td>" + RuleItemsList2Html(rule.Destination, rule.DestinationNegated, CheckPointObject.Any, ref dummy) + "</td>");
                        file.WriteLine("      <td>" + RuleItemsList2Html(rule.Service, false, CheckPointObject.Any, ref dummy) + "</td>");
                        file.WriteLine("      <td class='" + actionStyle + "'>" + action + "</td>");
                        file.WriteLine("      <td>" + RuleItemsList2Html(rule.Time, false, CheckPointObject.Any, ref dummy) + "</td>");
                        file.WriteLine("      <td>" + rule.Track.ToString() + "</td>");
                        file.WriteLine("      <td>" + rule.Comments + "</td>");
                        file.WriteLine("      <td>" + rule.ConversionComments + "</td>");
                        file.WriteLine("  </tr>");

                        if (isSubPolicy)
                        {
                            foreach (CheckPoint_Layer subPolicy in package.SubPolicies)
                            {
                                int subRuleNumber = 1;

                                foreach (CheckPoint_Rule subRule in subPolicy.Rules)
                                {
                                    if (subRule.Layer == rule.SubPolicyName)
                                    {
                                        bool isSubSubPolicy = false;
                                        string subAction = "";
                                        string subActionStyle = "";

                                        switch (subRule.Action)
                                        {
                                            case CheckPoint_Rule.ActionType.Accept:
                                            case CheckPoint_Rule.ActionType.Drop:
                                            case CheckPoint_Rule.ActionType.Reject:
                                                subAction = subRule.Action.ToString();
                                                subActionStyle = subRule.Action.ToString().ToLower();
                                                break;

                                            case CheckPoint_Rule.ActionType.SubPolicy:
                                                isSubSubPolicy = true;
                                                subAction = "Sub-policy: " + subRule.SubPolicyName;
                                                subActionStyle = "";
                                                break;
                                        }

                                        var ruleConversionIncidentType = ConversionIncidentType.None;
                                        bool isInspectedRule = !string.IsNullOrEmpty(subRule.Tag);
                                        string curRuleNumber = ruleNumber + "." + subRuleNumber;
                                        string curRuleId = ruleIdPrefix + curRuleNumber;

                                        if (subRule.Enabled)
                                        {
                                            file.WriteLine("  <tr id=\"" + curRuleId + "\">");
                                        }
                                        else
                                        {
                                            file.WriteLine("  <tr class='disabled_rule' id=\"" + curRuleId + "\">");
                                        }

                                        var sbCurRuleNumberColumnTag = new StringBuilder();
                                        sbCurRuleNumberColumnTag.Append("      <td class='indent_rule_number'/>");
                                        if (isSubSubPolicy)
                                        {
                                            sbCurRuleNumberColumnTag.Append("      <td class='rule_number' colspan='2' onclick='toggleSubRules(this)'>" +
                                                string.Format(HtmlSubPolicyArrowImageTagFormat, curRuleId + "_img", HtmlDownArrowImageSourceData) + curRuleNumber);
                                        }
                                        else
                                        {
                                            sbCurRuleNumberColumnTag.Append("      <td class='rule_number' colspan='2'>");
                                            sbCurRuleNumberColumnTag.Append(curRuleNumber);
                                        }

                                        if (isInspectedRule)
                                        {
                                            sbCurRuleNumberColumnTag.Append(BuildInspectedRuleInfo(subRule.Tag));
                                        }
                                        if (subRule.ConversionIncidentType != ConversionIncidentType.None)
                                        {
                                            sbCurRuleNumberColumnTag.Append(BuildConversionIncidentLinkTag(subRule.ConvertedCommandId));
                                            ruleConversionIncidentType = subRule.ConversionIncidentType;
                                        }
                                        if (!subRule.Enabled)
                                        {
                                            sbCurRuleNumberColumnTag.Append(HtmlDisabledImageTag);
                                        }
                                        sbCurRuleNumberColumnTag.Append("</td>");
                                        file.WriteLine(sbCurRuleNumberColumnTag.ToString());

                                        file.WriteLine("      <td>" + subRule.Name + "</td>");
                                        file.WriteLine("      <td>" + RuleItemsList2Html(subRule.Source, subRule.SourceNegated, CheckPointObject.Any, ref ruleConversionIncidentType) + "</td>");
                                        file.WriteLine("      <td>" + RuleItemsList2Html(subRule.Destination, subRule.DestinationNegated, CheckPointObject.Any, ref ruleConversionIncidentType) + "</td>");
                                        file.WriteLine("      <td>" + RuleItemsList2Html(subRule.Service, false, CheckPointObject.Any, ref ruleConversionIncidentType) + "</td>");
                                        //file.WriteLine("      <td class='" + subRule.Action.ToString().ToLower() + "'>" + subRule.Action.ToString() + "</td>");
                                        file.WriteLine("      <td class='" + subActionStyle + "'>" + subAction + "</td>");
                                        file.WriteLine("      <td>" + RuleItemsList2Html(subRule.Time, false, CheckPointObject.Any, ref ruleConversionIncidentType) + "</td>");
                                        file.WriteLine("      <td>" + subRule.Track.ToString() + "</td>");
                                        file.WriteLine("      <td class='comments'>" + subRule.Comments + "</td>");
                                        file.WriteLine("      <td class='comments'>" + subRule.ConversionComments + "</td>");
                                        file.WriteLine("  </tr>");

                                        if (isSubSubPolicy)
                                        {
                                            foreach (CheckPoint_Layer subSubPolicy in package.SubPolicies)
                                            {
                                                int subSubRuleNumber = 1;

                                                foreach (CheckPoint_Rule subSubRule in subSubPolicy.Rules)
                                                {
                                                    //if (subSubRule.Layer == subRule.SubPolicyName || subSubRule.Layer == subRule.SubPolicyName + "_opt")
                                                    if (subSubRule.Layer == subRule.SubPolicyName)
                                                    {
                                                        var subRuleConversionIncidentType = ConversionIncidentType.None;
                                                        string subCurRuleNumber = ruleNumber + "." + subRuleNumber + "." + subSubRuleNumber;
                                                        string subCurRuleId = ruleIdPrefix + subCurRuleNumber;

                                                        if (subSubRule.Enabled)
                                                        {
                                                            file.WriteLine("  <tr id=\"" + subCurRuleId + "\">");
                                                        }
                                                        else
                                                        {
                                                            file.WriteLine("  <tr class='disabled_rule' id=\"" + subCurRuleId + "\">");
                                                        }

                                                        var sbSubCurRuleNumberColumnTag = new StringBuilder();
                                                        sbSubCurRuleNumberColumnTag.Append("      <td class='indent_rule_number'/>");
                                                        sbSubCurRuleNumberColumnTag.Append("      <td class='indent_rule_number'/>");
                                                        sbSubCurRuleNumberColumnTag.Append("      <td class='rule_number'>");
                                                        sbSubCurRuleNumberColumnTag.Append(subCurRuleNumber);
                                                        if (subSubRule.ConversionIncidentType != ConversionIncidentType.None)
                                                        {
                                                            sbSubCurRuleNumberColumnTag.Append(BuildConversionIncidentLinkTag(subSubRule.ConvertedCommandId));
                                                            subRuleConversionIncidentType = subSubRule.ConversionIncidentType;
                                                        }
                                                        if (!subSubRule.Enabled)
                                                        {
                                                            sbSubCurRuleNumberColumnTag.Append(HtmlDisabledImageTag);
                                                        }
                                                        sbSubCurRuleNumberColumnTag.Append("</td>");
                                                        file.WriteLine(sbSubCurRuleNumberColumnTag.ToString());

                                                        file.WriteLine("      <td>" + subSubRule.Name + "</td>");
                                                        file.WriteLine("      <td>" + RuleItemsList2Html(subSubRule.Source, subSubRule.SourceNegated, CheckPointObject.Any, ref subRuleConversionIncidentType) + "</td>");
                                                        file.WriteLine("      <td>" + RuleItemsList2Html(subSubRule.Destination, subSubRule.DestinationNegated, CheckPointObject.Any, ref subRuleConversionIncidentType) + "</td>");
                                                        file.WriteLine("      <td>" + RuleItemsList2Html(subSubRule.Service, false, CheckPointObject.Any, ref subRuleConversionIncidentType) + "</td>");
                                                        file.WriteLine("      <td class='" + subSubRule.Action.ToString().ToLower() + "'>" + subSubRule.Action.ToString() + "</td>");
                                                        file.WriteLine("      <td>" + RuleItemsList2Html(subSubRule.Time, false, CheckPointObject.Any, ref subRuleConversionIncidentType) + "</td>");
                                                        file.WriteLine("      <td>" + subSubRule.Track.ToString() + "</td>");
                                                        file.WriteLine("      <td class='comments'>" + subSubRule.Comments + "</td>");
                                                        file.WriteLine("      <td class='comments'>" + subSubRule.ConversionComments + "</td>");
                                                        file.WriteLine("  </tr>");

                                                        subSubRuleNumber++;

                                                        if (package.ConversionIncidentType != ConversionIncidentType.None && subRuleConversionIncidentType != ConversionIncidentType.None)
                                                        {
                                                            if (subRuleConversionIncidentType == ConversionIncidentType.ManualActionRequired)
                                                            {
                                                                rulesWithConversionErrors.Add(subCurRuleId, subSubRule);
                                                            }
                                                            else
                                                            {
                                                                rulesWithConversionInfos.Add(subCurRuleId, subSubRule);
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                        }


                                        subRuleNumber++;

                                        if (package.ConversionIncidentType != ConversionIncidentType.None && ruleConversionIncidentType != ConversionIncidentType.None)
                                        {
                                            if (ruleConversionIncidentType == ConversionIncidentType.ManualActionRequired)
                                            {
                                                rulesWithConversionErrors.Add(curRuleId, subRule);
                                            }
                                            else
                                            {
                                                rulesWithConversionInfos.Add(curRuleId, subRule);
                                            }
                                        }

                                        if (isInspectedRule)
                                        {
                                            string[] ciscoClassMapNames = subRule.Tag.Split(',');   // there may be several class-maps matching the same fw rule...
                                            subRule.Tag = curRuleId;   // replace class-map name (it is now the key of this dic) by curRuleId...

                                            foreach (var classMapName in ciscoClassMapNames)
                                            {
                                                if (!rulesWithInspection.ContainsKey(classMapName))
                                                {
                                                    var inspectedRules = new List<CheckPoint_Rule>();
                                                    rulesWithInspection.Add(classMapName, inspectedRules);
                                                }
                                                rulesWithInspection[classMapName].Add(subRule);
                                            }
                                        }
                                    }
                                }
                            }
                        }

                        ruleNumber++;
                    }

                    file.WriteLine("</table>");

                    if (rulesWithConversionErrors.Count > 0 || rulesWithConversionInfos.Count > 0 || rulesWithInspection.Count > 0)
                    {
                        file.WriteLine("<div id=\"PolicyConversionIncidents\" style='margin-left: 20px;'><h2>Policy Conversion Issues</h2></div>");
                    }

                    // Generate the errors report
                    if (rulesWithConversionErrors.Count > 0)
                    {
                        file.WriteLine("<script>");
                        file.WriteLine("   errorsCounter = " + rulesWithConversionErrors.Count + ";");
                        file.WriteLine("</script>");

                        file.WriteLine("<div id=\"PolicyConversionErrors\" style='margin-left: 20px;'><h3>Conversion Errors</h3></div>");
                        file.WriteLine("<table style='background-color: rgb(255,255,150);'>");
                        file.WriteLine("   <tr>");
                        file.WriteLine("      <th class='errors_header'>No.</th> <th class='errors_header'>Name</th> <th class='errors_header'>Source</th> <th class='errors_header'>Destination</th> <th class='errors_header'>Service</th> <th class='errors_header'>Action</th> <th class='errors_header'>Time</th> <th class='errors_header'>Track</th> <th class='errors_header'>Comments</th> <th class='errors_header'>Conversion Comments</th>");
                        file.WriteLine("   </tr>");

                        foreach (var ruleEntry in rulesWithConversionErrors)
                        {
                            var dummy = ConversionIncidentType.None;

                            if (ruleEntry.Value.Enabled)
                            {
                                file.WriteLine("  <tr>");
                            }
                            else
                            {
                                file.WriteLine("  <tr class='disabled_rule'>");
                            }

                            var sbCurRuleNumberColumnTag = new StringBuilder();
                            sbCurRuleNumberColumnTag.Append("      <td class='rule_number'>");
                            sbCurRuleNumberColumnTag.Append("<a href=\"#");
                            sbCurRuleNumberColumnTag.Append(ruleEntry.Key);
                            sbCurRuleNumberColumnTag.Append("\">");
                            sbCurRuleNumberColumnTag.Append(ruleEntry.Key.Replace(ruleIdPrefix, ""));
                            sbCurRuleNumberColumnTag.Append("</a>");
                            if (ruleEntry.Value.ConversionIncidentType != ConversionIncidentType.None)
                            {
                                sbCurRuleNumberColumnTag.Append(BuildConversionIncidentLinkTag(ruleEntry.Value.ConvertedCommandId));
                            }
                            if (!ruleEntry.Value.Enabled)
                            {
                                sbCurRuleNumberColumnTag.Append(HtmlDisabledImageTag);
                            }
                            sbCurRuleNumberColumnTag.Append("</td>");
                            file.WriteLine(sbCurRuleNumberColumnTag.ToString());

                            file.WriteLine("      <td>" + ruleEntry.Value.Name + "</td>");
                            file.WriteLine("      <td>" + RuleItemsList2Html(ruleEntry.Value.Source, ruleEntry.Value.SourceNegated, CheckPointObject.Any, ref dummy) + "</td>");
                            file.WriteLine("      <td>" + RuleItemsList2Html(ruleEntry.Value.Destination, ruleEntry.Value.DestinationNegated, CheckPointObject.Any, ref dummy) + "</td>");
                            file.WriteLine("      <td>" + RuleItemsList2Html(ruleEntry.Value.Service, false, CheckPointObject.Any, ref dummy) + "</td>");
                            file.WriteLine("      <td class='" + ruleEntry.Value.Action.ToString().ToLower() + "'>" + ruleEntry.Value.Action.ToString() + "</td>");
                            file.WriteLine("      <td>" + RuleItemsList2Html(ruleEntry.Value.Time, false, CheckPointObject.Any, ref dummy) + "</td>");
                            file.WriteLine("      <td>" + ruleEntry.Value.Track.ToString() + "</td>");
                            file.WriteLine("      <td class='comments'>" + ruleEntry.Value.Comments + "</td>");
                            file.WriteLine("      <td class='comments'>" + ruleEntry.Value.ConversionComments + "</td>");
                            file.WriteLine("  </tr>");
                        }

                        file.WriteLine("</table>");
                    }

                    if (rulesWithConversionInfos.Count > 0 || rulesWithInspection.Count > 0)
                    {
                        int counter = (rulesWithInspection.Count > 0) ? 1 : 0;
                        counter += rulesWithConversionInfos.Count;

                        file.WriteLine("<script>");
                        file.WriteLine("   infosCounter = " + counter + ";");
                        file.WriteLine("</script>");
                        file.WriteLine("<div id=\"PolicyConversionInfos\" style='margin-left: 20px;'><h3>Conversion Notifications</h3></div>");
                    }

                    // Generate the information report
                    if (rulesWithConversionInfos.Count > 0)
                    {
                        file.WriteLine("<table style='background-color: rgb(220,240,247);'>");
                        file.WriteLine("   <tr>");
                        file.WriteLine("      <th class='errors_header'>No.</th> <th class='errors_header'>Name</th> <th class='errors_header'>Source</th> <th class='errors_header'>Destination</th> <th class='errors_header'>Service</th> <th class='errors_header'>Action</th> <th class='errors_header'>Time</th> <th class='errors_header'>Track</th> <th class='errors_header'>Comments</th> <th class='errors_header'>Conversion Comments</th>");
                        file.WriteLine("   </tr>");

                        foreach (var ruleEntry in rulesWithConversionInfos)
                        {
                            var dummy = ConversionIncidentType.None;

                            if (ruleEntry.Value.Enabled)
                            {
                                file.WriteLine("  <tr>");
                            }
                            else
                            {
                                file.WriteLine("  <tr class='disabled_rule'>");
                            }

                            var sbCurRuleNumberColumnTag = new StringBuilder();
                            sbCurRuleNumberColumnTag.Append("      <td class='rule_number'>");
                            sbCurRuleNumberColumnTag.Append("<a href=\"#");
                            sbCurRuleNumberColumnTag.Append(ruleEntry.Key);
                            sbCurRuleNumberColumnTag.Append("\">");
                            sbCurRuleNumberColumnTag.Append(ruleEntry.Key.Replace(ruleIdPrefix, ""));
                            sbCurRuleNumberColumnTag.Append("</a>");
                            if (ruleEntry.Value.ConversionIncidentType != ConversionIncidentType.None)
                            {
                                sbCurRuleNumberColumnTag.Append(BuildConversionIncidentLinkTag(ruleEntry.Value.ConvertedCommandId));
                            }
                            if (!ruleEntry.Value.Enabled)
                            {
                                sbCurRuleNumberColumnTag.Append(HtmlDisabledImageTag);
                            }
                            sbCurRuleNumberColumnTag.Append("</td>");
                            file.WriteLine(sbCurRuleNumberColumnTag.ToString());

                            file.WriteLine("      <td>" + ruleEntry.Value.Name + "</td>");
                            file.WriteLine("      <td>" + RuleItemsList2Html(ruleEntry.Value.Source, ruleEntry.Value.SourceNegated, CheckPointObject.Any, ref dummy) + "</td>");
                            file.WriteLine("      <td>" + RuleItemsList2Html(ruleEntry.Value.Destination, ruleEntry.Value.DestinationNegated, CheckPointObject.Any, ref dummy) + "</td>");
                            file.WriteLine("      <td>" + RuleItemsList2Html(ruleEntry.Value.Service, false, CheckPointObject.Any, ref dummy) + "</td>");
                            file.WriteLine("      <td class='" + ruleEntry.Value.Action.ToString().ToLower() + "'>" + ruleEntry.Value.Action.ToString() + "</td>");
                            file.WriteLine("      <td>" + RuleItemsList2Html(ruleEntry.Value.Time, false, CheckPointObject.Any, ref dummy) + "</td>");
                            file.WriteLine("      <td>" + ruleEntry.Value.Track.ToString() + "</td>");
                            file.WriteLine("      <td class='comments'>" + ruleEntry.Value.Comments + "</td>");
                            file.WriteLine("      <td class='comments'>" + ruleEntry.Value.ConversionComments + "</td>");
                            file.WriteLine("  </tr>");
                        }

                        file.WriteLine("</table>");
                    }

                    // Generate the inspected rules report
                    if (rulesWithInspection.Count > 0)
                    {
                        file.WriteLine("<div style='margin-left: 20px;'><h3>Inspected Rules</h3></div>");
                        file.WriteLine("<div style='margin-left: 20px; margin-bottom: 20px;'>");
                        file.WriteLine("   <span style='vertical-align: middle;'>" + HtmlAlertImageTagFormat + "</span>");
                        file.WriteLine("   <span> The following firewall rules are matched by ");
                        file.WriteLine("      <a href='http://www.cisco.com/c/en/us/td/docs/security/asa/asa84/configuration/guide/asa_84_cli_config/mpf_inspect_maps.html' target='_blank'>Cisco Inspect classes</a>.");
                        file.WriteLine(" Please review for further possible modifications to rules after migration.</span>");
                        file.WriteLine("</div>");

                        foreach (var inspectionInfo in rulesWithInspection)
                        {
                            file.WriteLine("<div style='font-size: 14px; margin-left: 20px; margin-bottom: 15px;'>");
                            file.WriteLine("   <span>Cisco Inspect class-map: </span><span>" + BuildInspectedRuleLinkTag(inspectionInfo.Key) + "</span>");
                            file.WriteLine("</div>");

                            file.WriteLine("<table style='background-color: rgb(220,240,247);'>");
                            file.WriteLine("   <tr>");
                            file.WriteLine("      <th class='errors_header'>No.</th> <th class='errors_header'>Name</th> <th class='errors_header'>Source</th> <th class='errors_header'>Destination</th> <th class='errors_header'>Service</th> <th class='errors_header'>Action</th> <th class='errors_header'>Time</th> <th class='errors_header'>Track</th> <th class='errors_header'>Comments</th> <th class='errors_header'>Conversion Comments</th>");
                            file.WriteLine("   </tr>");

                            foreach (var ruleEntry in inspectionInfo.Value)
                            {
                                var dummy = ConversionIncidentType.None;

                                if (ruleEntry.Enabled)
                                {
                                    file.WriteLine("  <tr>");
                                }
                                else
                                {
                                    file.WriteLine("  <tr class='disabled_rule'>");
                                }

                                var sbRuleNumberColumnTag = new StringBuilder();
                                sbRuleNumberColumnTag.Append("      <td class='rule_number'>");
                                sbRuleNumberColumnTag.Append("<a href=\"#");
                                sbRuleNumberColumnTag.Append(ruleEntry.Tag);
                                sbRuleNumberColumnTag.Append("\">");
                                sbRuleNumberColumnTag.Append(ruleEntry.Tag.Replace(ruleIdPrefix, ""));
                                sbRuleNumberColumnTag.Append("</a>");
                                if (ruleEntry.ConversionIncidentType != ConversionIncidentType.None)
                                {
                                    sbRuleNumberColumnTag.Append(BuildConversionIncidentLinkTag(ruleEntry.ConvertedCommandId));
                                }
                                if (!ruleEntry.Enabled)
                                {
                                    sbRuleNumberColumnTag.Append(HtmlDisabledImageTag);
                                }
                                sbRuleNumberColumnTag.Append("</td>");
                                file.WriteLine(sbRuleNumberColumnTag.ToString());

                                file.WriteLine("      <td>" + ruleEntry.Name + "</td>");
                                file.WriteLine("      <td>" + RuleItemsList2Html(ruleEntry.Source, ruleEntry.SourceNegated, CheckPointObject.Any, ref dummy) + "</td>");
                                file.WriteLine("      <td>" + RuleItemsList2Html(ruleEntry.Destination, ruleEntry.DestinationNegated, CheckPointObject.Any, ref dummy) + "</td>");
                                file.WriteLine("      <td>" + RuleItemsList2Html(ruleEntry.Service, false, CheckPointObject.Any, ref dummy) + "</td>");
                                file.WriteLine("      <td class='" + ruleEntry.Action.ToString().ToLower() + "'>" + ruleEntry.Action.ToString() + "</td>");
                                file.WriteLine("      <td>" + RuleItemsList2Html(ruleEntry.Time, false, CheckPointObject.Any, ref dummy) + "</td>");
                                file.WriteLine("      <td>" + ruleEntry.Track.ToString() + "</td>");
                                file.WriteLine("      <td class='comments'>" + ruleEntry.Comments + "</td>");
                                file.WriteLine("      <td class='comments'>" + ruleEntry.ConversionComments + "</td>");
                                file.WriteLine("  </tr>");
                            }

                            file.WriteLine("</table>");
                        }
                    }

                    file.WriteLine("</body>");
                    file.WriteLine("</html>");
                }
            }
        }

        protected override string GetVendorName()
        {
            return Vendor.CiscoASA.ToString();
        }
        #endregion
    }
}
